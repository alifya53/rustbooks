<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    
<!-- Mirrored from docs.rust-embedded.org/discovery/print.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 03 Nov 2019 13:54:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index-2.html">Introduction</a></li><li><a href="01-background/index.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><a href="02-requirements/index.html"><strong aria-hidden="true">2.</strong> Hardware/knowledge requirements</a></li><li><a href="03-setup/index.html"><strong aria-hidden="true">3.</strong> Setting up a development environment</a></li><li><ol class="section"><li><a href="03-setup/linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li><a href="03-setup/windows.html"><strong aria-hidden="true">3.2.</strong> Windows</a></li><li><a href="03-setup/macos.html"><strong aria-hidden="true">3.3.</strong> macOS</a></li><li><a href="03-setup/verify.html"><strong aria-hidden="true">3.4.</strong> Verify the installation</a></li></ol></li><li><a href="04-meet-your-hardware/index.html"><strong aria-hidden="true">4.</strong> Meet your hardware</a></li><li><a href="05-led-roulette/index.html"><strong aria-hidden="true">5.</strong> LED roulette</a></li><li><ol class="section"><li><a href="05-led-roulette/build-it.html"><strong aria-hidden="true">5.1.</strong> Build it</a></li><li><a href="05-led-roulette/flash-it.html"><strong aria-hidden="true">5.2.</strong> Flash it</a></li><li><a href="05-led-roulette/debug-it.html"><strong aria-hidden="true">5.3.</strong> Debug it</a></li><li><a href="05-led-roulette/the-led-and-delay-abstractions.html"><strong aria-hidden="true">5.4.</strong> The led and delay abstractions</a></li><li><a href="05-led-roulette/the-challenge.html"><strong aria-hidden="true">5.5.</strong> The challenge</a></li><li><a href="05-led-roulette/my-solution.html"><strong aria-hidden="true">5.6.</strong> My solution</a></li></ol></li><li><a href="06-hello-world/index.html"><strong aria-hidden="true">6.</strong> Hello, world!</a></li><li><ol class="section"><li><a href="06-hello-world/panic.html"><strong aria-hidden="true">6.1.</strong> panic!</a></li></ol></li><li><a href="07-registers/index.html"><strong aria-hidden="true">7.</strong> Registers</a></li><li><ol class="section"><li><a href="07-registers/rtrm.html"><strong aria-hidden="true">7.1.</strong> RTRM</a></li><li><a href="07-registers/optimization.html"><strong aria-hidden="true">7.2.</strong> (mis)Optimization</a></li><li><a href="07-registers/bad-address.html"><strong aria-hidden="true">7.3.</strong> 0xBAAAAAAD address</a></li><li><a href="07-registers/spooky-action-at-a-distance.html"><strong aria-hidden="true">7.4.</strong> Spooky action at a distance</a></li><li><a href="07-registers/type-safe-manipulation.html"><strong aria-hidden="true">7.5.</strong> Type safe manipulation</a></li></ol></li><li><a href="08-leds-again/index.html"><strong aria-hidden="true">8.</strong> LEDs, again</a></li><li><ol class="section"><li><a href="08-leds-again/power.html"><strong aria-hidden="true">8.1.</strong> Power</a></li><li><a href="08-leds-again/configuration.html"><strong aria-hidden="true">8.2.</strong> Configuration</a></li><li><a href="08-leds-again/the-solution.html"><strong aria-hidden="true">8.3.</strong> The solution</a></li></ol></li><li><a href="09-clocks-and-timers/index.html"><strong aria-hidden="true">9.</strong> Clocks and timers</a></li><li><ol class="section"><li><a href="09-clocks-and-timers/for-loop-delays.html"><strong aria-hidden="true">9.1.</strong> for loop delays</a></li><li><a href="09-clocks-and-timers/nop.html"><strong aria-hidden="true">9.2.</strong> NOP</a></li><li><a href="09-clocks-and-timers/one-shot-timer.html"><strong aria-hidden="true">9.3.</strong> One-shot timer</a></li><li><a href="09-clocks-and-timers/initialization.html"><strong aria-hidden="true">9.4.</strong> Initialization</a></li><li><a href="09-clocks-and-timers/busy-waiting.html"><strong aria-hidden="true">9.5.</strong> Busy waiting</a></li><li><a href="09-clocks-and-timers/putting-it-all-together.html"><strong aria-hidden="true">9.6.</strong> Putting it all together</a></li></ol></li><li><a href="10-serial-communication/index.html"><strong aria-hidden="true">10.</strong> Serial communication</a></li><li><ol class="section"><li><a href="10-serial-communication/nix-tooling.html"><strong aria-hidden="true">10.1.</strong> *nix tooling</a></li><li><a href="10-serial-communication/windows-tooling.html"><strong aria-hidden="true">10.2.</strong> Windows tooling</a></li><li><a href="10-serial-communication/loopbacks.html"><strong aria-hidden="true">10.3.</strong> Loopbacks</a></li></ol></li><li><a href="11-usart/index.html"><strong aria-hidden="true">11.</strong> USART</a></li><li><ol class="section"><li><a href="11-usart/send-a-single-byte.html"><strong aria-hidden="true">11.1.</strong> Send a single byte</a></li><li><a href="11-usart/send-a-string.html"><strong aria-hidden="true">11.2.</strong> Send a string</a></li><li><a href="11-usart/buffer-overrun.html"><strong aria-hidden="true">11.3.</strong> Buffer overrun</a></li><li><a href="11-usart/uprintln.html"><strong aria-hidden="true">11.4.</strong> uprintln!</a></li><li><a href="11-usart/receive-a-single-byte.html"><strong aria-hidden="true">11.5.</strong> Receive a single byte</a></li><li><a href="11-usart/echo-server.html"><strong aria-hidden="true">11.6.</strong> Echo server</a></li><li><a href="11-usart/reverse-a-string.html"><strong aria-hidden="true">11.7.</strong> Reverse a string</a></li><li><a href="11-usart/my-solution.html"><strong aria-hidden="true">11.8.</strong> My solution</a></li></ol></li><li><a href="12-bluetooth-setup/index.html"><strong aria-hidden="true">12.</strong> Bluetooth setup</a></li><li><ol class="section"><li><a href="12-bluetooth-setup/linux.html"><strong aria-hidden="true">12.1.</strong> Linux</a></li><li><a href="12-bluetooth-setup/loopback.html"><strong aria-hidden="true">12.2.</strong> Loopback</a></li></ol></li><li><a href="13-serial-over-bluetooth/index.html"><strong aria-hidden="true">13.</strong> Serial over Bluetooth</a></li><li><a href="14-i2c/index.html"><strong aria-hidden="true">14.</strong> I2C</a></li><li><ol class="section"><li><a href="14-i2c/the-general-protocol.html"><strong aria-hidden="true">14.1.</strong> The general protocol</a></li><li><a href="14-i2c/lsm303dlhc.html"><strong aria-hidden="true">14.2.</strong> LSM303DLHC</a></li><li><a href="14-i2c/read-a-single-register.html"><strong aria-hidden="true">14.3.</strong> Read a single register</a></li><li><a href="14-i2c/the-solution.html"><strong aria-hidden="true">14.4.</strong> The solution</a></li><li><a href="14-i2c/read-several-registers.html"><strong aria-hidden="true">14.5.</strong> Read several registers</a></li></ol></li><li><a href="15-led-compass/index.html"><strong aria-hidden="true">15.</strong> LED compass</a></li><li><ol class="section"><li><a href="15-led-compass/take-1.html"><strong aria-hidden="true">15.1.</strong> Take 1</a></li><li><a href="15-led-compass/solution-1.html"><strong aria-hidden="true">15.2.</strong> Solution 1</a></li><li><a href="15-led-compass/take-2.html"><strong aria-hidden="true">15.3.</strong> Take 2</a></li><li><a href="15-led-compass/solution-2.html"><strong aria-hidden="true">15.4.</strong> Solution 2</a></li><li><a href="15-led-compass/magnitude.html"><strong aria-hidden="true">15.5.</strong> Magnitude</a></li><li><a href="15-led-compass/calibration.html"><strong aria-hidden="true">15.6.</strong> Calibration</a></li></ol></li><li><a href="16-punch-o-meter/index.html"><strong aria-hidden="true">16.</strong> Punch-o-meter</a></li><li><ol class="section"><li><a href="16-punch-o-meter/gravity-is-up.html"><strong aria-hidden="true">16.1.</strong> Gravity is up?</a></li><li><a href="16-punch-o-meter/the-challenge.html"><strong aria-hidden="true">16.2.</strong> The challenge</a></li><li><a href="16-punch-o-meter/my-solution.html"><strong aria-hidden="true">16.3.</strong> My solution</a></li></ol></li><li><a href="explore.html"><strong aria-hidden="true">17.</strong> What's left for you to explore</a></li><li class="spacer"></li><li class="affix"><a href="appendix/1-general-troubleshooting/index.html">General troubleshooting</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#discovery" id="discovery"><h1>Discovery</h1></a>
<blockquote>
<p>Discover the world of microcontrollers through <a href="https://www.rust-lang.org/">Rust</a>!</p>
</blockquote>
<p>This book is an introductory course on microcontroller-based embedded systems that uses Rust as the
teaching language rather than the usual C/C++.</p>
<a class="header" href="#scope" id="scope"><h2>Scope</h2></a>
<p>The following topics will be covered (eventually, I hope):</p>
<ul>
<li>
<p>How to write, build, flash and debug an &quot;embedded&quot; (Rust) program.</p>
</li>
<li>
<p>Functionality (&quot;peripherals&quot;) commonly found in microcontrollers: Digital input and output, Pulse
Width Modulation (PWM), Analog to Digital Converters (ADC), common communication protocols like
Serial, I2C and SPI, etc.</p>
</li>
<li>
<p>Multitasking concepts: cooperative vs preemptive multitasking, interrupts, schedulers, etc.</p>
</li>
<li>
<p>Control systems concepts: sensors, calibration, digital filters, actuators, open loop control,
closed loop control, etc.</p>
</li>
</ul>
<a class="header" href="#approach" id="approach"><h2>Approach</h2></a>
<ul>
<li>
<p>Beginner friendly. No previous experience with microcontrollers or embedded systems is required.</p>
</li>
<li>
<p>Hands on. Plenty of exercises to put the theory into practice. <em>You</em> will be doing most of the
work here.</p>
</li>
<li>
<p>Tool centered. We'll make plenty use of tooling to ease development. &quot;Real&quot; debugging, with GDB,
and logging will be introduced early on. Using LEDs as a debugging mechanism has no place here.</p>
</li>
</ul>
<a class="header" href="#non-goals" id="non-goals"><h2>Non-goals</h2></a>
<p>What's out of scope for this book:</p>
<ul>
<li>
<p>Teaching Rust. There's plenty of material on that topic already. We'll focus on microcontrollers
and embedded systems.</p>
</li>
<li>
<p>Being a comprehensive text about electric circuit theory or electronics. We'll just cover the
minimum required to understand how some devices work.</p>
</li>
<li>
<p>Covering Rustic, low level details. We won't be talking about linker scripts, the boot process or
how to glue those two into a minimally working Rust program.</p>
</li>
</ul>
<p>Also I don't intend to port this material to other development boards; this book will make exclusive
use of the STM32F3DISCOVERY development board.</p>
<a class="header" href="#reporting-problems" id="reporting-problems"><h2>Reporting problems</h2></a>
<p>The source of this book is in <a href="https://github.com/rust-embedded/discovery">this repository</a>. If you encounter any typo or problem with the code
report it on the <a href="https://github.com/rust-embedded/discovery/issues">issue tracker</a>.</p>
<a class="header" href="#other-embedded-rust-resources" id="other-embedded-rust-resources"><h2>Other embedded Rust resources</h2></a>
<p>This Discovery book is just one of several embedded Rust resources provided by the
<a href="https://github.com/rust-embedded/wg">Embedded Working Group</a>. The full selection can be found at <a href="https://docs.rust-embedded.org/">The Embedded Rust Bookshelf</a>. This
includes the list of <a href="https://docs.rust-embedded.org/faq.html">Frequently Asked Questions</a>.</p>
<a class="header" href="#sponsored-by" id="sponsored-by"><h2>Sponsored by</h2></a>
<p align="center">
<a href="http://integer32.com/">
<img style="width: 50%" title="integer 32" src="assets/integer32.svg">
</a>
</p>
<p>Many thanks to <a href="http://integer32.com/">integer 32</a> for sponsoring me to work on this book! Please
give them lots of work (they do Rust consulting!) so they'll have no choice but to hire more
Rustaceans &lt;3.</p>
<a class="header" href="#background" id="background"><h1>Background</h1></a>
<a class="header" href="#whats-a-microcontroller" id="whats-a-microcontroller"><h2>What's a microcontroller?</h2></a>
<p>A microcontroller is a <em>system</em> on a chip. Whereas your laptop is made up of several discrete
components: a processor, RAM sticks, a hard drive, an ethernet port, etc.; a microcontroller has all
those components built into a single &quot;chip&quot; or package. This makes it possible to build systems with
minimal part count.</p>
<a class="header" href="#what-can-you-do-with-a-microcontroller" id="what-can-you-do-with-a-microcontroller"><h2>What can you do with a microcontroller?</h2></a>
<p>Lots of things! Microcontrollers are the central part of systems known as <em>embedded</em> systems. These
systems are everywhere but you don't usually notice them. These systems control the brakes of your
car, wash your clothes, print your documents, keep you warm, keep you cool, optimize the fuel
consumption of your car, etc.</p>
<p>The main trait of these systems is that they operate without user intervention even if they expose a
user interface like a washing machine does; most of their operation is done on their own.</p>
<p>The other common trait of these systems is that they <em>control</em> a process. And for that these systems
usually have one or more sensors and one or more actuators. For example, an HVAC system has several
sensors, thermometers and humidity sensors spread across some area, and several actuators as well,
heating elements and fans connected to ducts.</p>
<a class="header" href="#when-should-i-use-a-microcontroller" id="when-should-i-use-a-microcontroller"><h2>When should I use a microcontroller?</h2></a>
<p>All these application I've mentioned, you can probably implement with a Raspberry Pi, a computer
that runs Linux. Why should I bother with a microcontroller that operates without an OS? Sounds like
it would be harder to develop a program.</p>
<p>The main reason is cost. A microcontroller is much cheaper than a general purpose computer. Not only
the microcontroller is cheaper; it also requires many fewer external electrical components to
operate. This makes Printed Circuit Boards (PCB) smaller and cheaper to design and manufacture.</p>
<p>The other big reason is power consumption. A microcontroller consumes orders of magnitude less power
than a full blown processor. If your application will run on batteries that makes a huge difference.</p>
<p>And last but not least: (hard) <em>real time</em> constraints. Some processes require their controllers to
respond to some events within some time interval (e.g. a quadcopter/drone hit by a wind gust). If
this <em>deadline</em> is not met, the process could end in catastrophic failure (e.g. the drone crashes to
the ground). A general purpose computer  running a general purpose OS has many services running in
the background. This makes it hard to guarantee execution of a program within tight time constraints.</p>
<a class="header" href="#when-should-i-not-use-a-microcontroller" id="when-should-i-not-use-a-microcontroller"><h2>When should I <em>not</em> use a microcontroller?</h2></a>
<p>Where heavy computations are involved. To keep their power consumption low, microcontrollers have
very limited computational resources available to them. For example, some microcontrollers don't
even have hardware support for floating point operations. On those devices, performing a simple
addition of single precision numbers can take hundreds of CPU cycles.</p>
<a class="header" href="#why-use-rust-and-not-c" id="why-use-rust-and-not-c"><h2>Why use Rust and not C?</h2></a>
<p>Hopefully, I don't need to convince you here as you are probably familiar with the language
differences between Rust and C. One point I do want to bring up is package management. C lacks an
official, widely accepted package management solution whereas Rust has Cargo. This makes development
<em>much</em> easier. And, IMO, easy package management encourages code reuse because libraries can be
easily integrated into an application which is also a good thing as libraries get more &quot;battle
testing&quot;.</p>
<a class="header" href="#why-should-i-not-use-rust" id="why-should-i-not-use-rust"><h2>Why should I not use Rust?</h2></a>
<p>Or why should I prefer C over Rust?</p>
<p>The C ecosystem is way more mature. Off the shelf solution for several problems already exist. If
you need to control a time sensitive process, you can grab one of the existing commercial Real Time
Operating Systems (RTOS) out there and solve your problem. There are no commercial, production-grade
RTOSes in Rust yet so you would have to either create one yourself or try one of the ones that are
in development.</p>
<a class="header" href="#hardwareknowledge-requirements" id="hardwareknowledge-requirements"><h1>Hardware/knowledge requirements</h1></a>
<p>The only knowledge requirement to read this book is to know <em>some</em> Rust. It's
hard for me to quantify <em>some</em> but at least I can tell you that you don't need
to fully grok generics but you do need to know how to <em>use</em> closures. You also
need to be familiar with the idioms of the <a href="https://rust-lang-nursery.github.io/edition-guide/">2018 edition</a>, in particular with
the fact that <code>extern crate</code> is not necessary in the 2018 edition.</p>
<p>Also, to follow this material you'll need the following hardware:</p>
<p>(Some components are optional but recommended)</p>
<ul>
<li>A <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> board.</li>
</ul>
<p>(You can purchase this board from &quot;big&quot; <a href="http://www.mouser.com/ProductDetail/STMicroelectronics/STM32F3DISCOVERY">electronics</a> <a href="http://www.digikey.com/product-detail/en/stmicroelectronics/STM32F3DISCOVERY/497-13192-ND">suppliers</a> or from <a href="https://www.aliexpress.com/wholesale?SearchText=stm32f3discovery">e-commerce</a>
<a href="http://www.ebay.com/sch/i.html?_nkw=stm32f3discovery">sites</a>)</p>
<p align="center">
<img title="STM32F3DISCOVERY" src="https://docs.rust-embedded.org/assets/f3.jpg">
</p>
<ul>
<li>OPTIONAL. A <strong>3.3V</strong> USB &lt;-&gt; Serial module. <a href="https://www.sparkfun.com/products/9873">This particular model</a> will be used
throughout this material but you can use any other model as long as it operates at 3.3V.</li>
</ul>
<p>(The (Chinese) CH340G module, which you can buy <a href="https://www.aliexpress.com/wholesale?SearchText=CH340G">e-commerce</a> sites, works too and it's probably
cheaper for you to get)</p>
<p align="center">
<img title="A 3.3v USB <-> Serial module" src="../assets/serial.jpg">
</p>
<ul>
<li>OPTIONAL. A HC-05 Bluetooth module (with headers!). A HC-06 would work too.</li>
</ul>
<p>(As with other Chinese parts, you pretty much can only find these on <a href="http://www.ebay.com/sch/i.html?_nkw=hc-05">e-commerce</a> <a href="https://www.aliexpress.com/wholesale?SearchText=hc-05">sites</a>.
(US) Electronics suppliers don't usually stock these for some reason)</p>
<p align="center">
<img title="The HC-05 Bluetooth module" src="https://docs.rust-embedded.org/assets/bluetooth.jpg">
</p>
<ul>
<li>Two mini-B USB cables. One is required to make the STM32F3DISCOVERY board work. The other is only
required if you have the Serial &lt;-&gt; USB module.</li>
</ul>
<p align="center">
<img title="mini-B USB cable" src="https://docs.rust-embedded.org/assets/usb-cable.jpg">
</p>
<blockquote>
<p><strong>NOTE</strong> These are <strong>not</strong> the USB cables that ship with pretty much every Android phone; those
are <em>micro</em> USB cables. Make sure you have the right thing!</p>
</blockquote>
<ul>
<li>MOSTLY OPTIONAL. 5 female to female, 4 male to female and 1 Male to Male <em>jumper</em> (AKA Dupont)
wires. You'll <em>very likely</em> need one female to female to get ITM working. The other wires are only
needed if you'll be using the USB &lt;-&gt; Serial and Bluetooth modules.</li>
</ul>
<p>(You can get these from electronics <a href="https://www.adafruit.com/categories/306">suppliers</a> or from <a href="http://www.ebay.com/sch/i.html?_nkw=dupont+wire">e-commerce</a> <a href="https://www.aliexpress.com/wholesale?SearchText=dupont+wire">sites</a>)</p>
<p align="center">
<img title="Jumper wires" src="https://docs.rust-embedded.org/assets/jumper-wires.jpg">
</p>
<blockquote>
<p><strong>FAQ</strong>: Wait, why do I need this specific hardware?</p>
</blockquote>
<p>It makes my life and yours much easier.</p>
<p>The material is much, much more approachable if we don't have to worry about hardware differences.
Trust me on this one.</p>
<blockquote>
<p><strong>FAQ</strong>: Can I follow this material with a different development board?</p>
</blockquote>
<p>Maybe? It depends mainly on two things: your previous experience with microcontrollers and/or
whether there already exists a high level crate, like the <a href="https://docs.rs/f3"><code>f3</code></a>, for your development board
somewhere.</p>
<p>With a different development board, this text would lose most if not all its beginner friendliness
and &quot;easy to follow&quot;-ness, IMO.</p>
<p>If you have a different development board and you don't consider yourself a total beginner, you are
better off starting with the <a href="https://rust-embedded.github.io/cortex-m-quickstart/cortex_m_quickstart/">quickstart</a> project template.</p>
<a class="header" href="#setting-up-a-development-environment" id="setting-up-a-development-environment"><h1>Setting up a development environment</h1></a>
<p>Dealing with microcontrollers involves several tools as we'll be dealing with an architecture
different than your laptop's and we'll have to run and debug programs on a &quot;remote&quot; device.</p>
<a class="header" href="#documentation" id="documentation"><h2>Documentation</h2></a>
<p>Tooling is not everything though. Without documentation it is pretty much impossible to work with
microcontrollers.</p>
<p>We'll be referring to all these documents throughout this book:</p>
<p><em>HEADS UP</em> All these links point to PDF files and some of them are hundreds of pages long and
several MBs in size.</p>
<ul>
<li><a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">STM32F3DISCOVERY User Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">STM32F303VC Datasheet</a></li>
<li><a href="http://www.st.com/resource/en/reference_manual/dm00043574.pdf">STM32F303VC Reference Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">LSM303DLHC</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/l3gd20.pdf">L3GD20</a></li>
</ul>
<a class="header" href="#tools" id="tools"><h2>Tools</h2></a>
<p>We'll use all the tools listed below. Where a minimum version is not specified, any recent version
should work but we have listed the version we have tested.</p>
<ul>
<li>
<p>Rust 1.31 or a newer toolchain.</p>
</li>
<li>
<p><a href="https://crates.io/crates/itm"><code>itmdump</code></a> v0.3.1</p>
</li>
<li>
<p>OpenOCD &gt;=0.8. Tested versions: v0.9.0 and v0.10.0</p>
</li>
<li>
<p><code>arm-none-eabi-gdb</code>. Version 7.12 or newer highly recommended. Tested versions: 7.10, 7.11,
7.12 and 8.1</p>
</li>
<li>
<p><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a>. Version 0.1.4 or newer.</p>
</li>
</ul>
<ul>
<li>
<p><code>minicom</code> on Linux and macOS. Tested version: 2.7. Readers report that <code>picocom</code> also works but
we'll use <code>minicom</code> in this text.</p>
</li>
<li>
<p><code>PuTTY</code> on Windows.</p>
</li>
</ul>
<p>If your laptop has Bluetooth functionality and you have the Bluetooth module, you can additionally
install these tools to play with the Bluetooth module. All these are optional:</p>
<ul>
<li>Linux, only if you don't have a Bluetooth manager application like Blueman.
<ul>
<li><code>bluez</code></li>
<li><code>hcitool</code></li>
<li><code>rfcomm</code></li>
<li><code>rfkill</code></li>
</ul>
</li>
</ul>
<p>macOS / OSX / Windows users only need the default bluetooth manager that ships with their OS.</p>
<p>Next, follow OS-agnostic installation instructions for a few of the tools:</p>
<a class="header" href="#rustc--cargo" id="rustc--cargo"><h3><code>rustc</code> &amp; Cargo</h3></a>
<p>Install rustup by following the instructions at <a href="https://rustup.rs/">https://rustup.rs</a>.</p>
<p>If you already have rustup installed double check that you are on the stable
channel and your stable toolchain is up to date. <code>rustc -V</code> should return a date
newer than the one shown below:</p>
<pre><code class="language-console">$ rustc -V
rustc 1.31.0 (abe02cefd 2018-12-04)
</code></pre>
<a class="header" href="#itmdump" id="itmdump"><h3><code>itmdump</code></h3></a>
<pre><code class="language-console">$ cargo install itm --vers 0.3.1

$ itmdump -V
itmdump 0.3.1
</code></pre>
<a class="header" href="#cargo-binutils" id="cargo-binutils"><h3><code>cargo-binutils</code></h3></a>
<pre><code class="language-console">$ rustup component add llvm-tools-preview

$ cargo install cargo-binutils --vers 0.1.4

$ cargo size -- -version
LLVM (http://llvm.org/):
  LLVM version 8.0.0svn
  Optimized build.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake
</code></pre>
<a class="header" href="#os-specific-instructions" id="os-specific-instructions"><h3>OS specific instructions</h3></a>
<p>Now follow the instructions specific to the OS you are using:</p>
<ul>
<li><a href="linux.html">Linux</a></li>
<li><a href="windows.html">Windows</a></li>
<li><a href="macos.html">macOS</a></li>
</ul>
<a class="header" href="#linux" id="linux"><h1>Linux</h1></a>
<p>Here are the installation commands for a few Linux distributions.</p>
<a class="header" href="#required-packages" id="required-packages"><h2>REQUIRED packages</h2></a>
<a class="header" href="#ubuntu-1804-or-newer--debian-stretch-or-newer" id="ubuntu-1804-or-newer--debian-stretch-or-newer"><h3>Ubuntu 18.04 or newer / Debian stretch or newer</h3></a>
<blockquote>
<p><strong>NOTE</strong> <code>gdb-multiarch</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<pre><code class="language-console">$ sudo apt-get install \
  gdb-multiarch \
  minicom \
  openocd
</code></pre>
<a class="header" href="#ubuntu-1404-and-1604" id="ubuntu-1404-and-1604"><h3>Ubuntu 14.04 and 16.04</h3></a>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 -->
<!-- OpenOCD 0.7.0 -->
<pre><code class="language-console">$ sudo apt-get install \
  gdb-arm-none-eabi \
  minicom \
  openocd
</code></pre>
<a class="header" href="#fedora-23-or-newer" id="fedora-23-or-newer"><h3>Fedora 23 or newer</h3></a>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<pre><code class="language-console">$ sudo dnf install \
  arm-none-eabi-gdb \
  minicom \
  openocd
</code></pre>
<a class="header" href="#arch-linux" id="arch-linux"><h3>Arch Linux</h3></a>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<pre><code class="language-console">$ sudo pacman -S \
  arm-none-eabi-gdb \
  minicom \
  openocd
</code></pre>
<a class="header" href="#other-distros" id="other-distros"><h3>Other distros</h3></a>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<p>For distros that don't have packages for <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">ARM's pre-built
toolchain</a>,
download the &quot;Linux 64-bit&quot; file and put its <code>bin</code> directory on your path.
Here's one way to do it:</p>
<pre><code class="language-console">$ mkdir -p ~/local &amp;&amp; cd ~/local
$ tar xjf /path/to/downloaded/file/gcc-arm-none-eabi-7-2017-q4-major-linux.tar.bz2.tbz
</code></pre>
<p>Then, use your editor of choice to append to your <code>PATH</code> in the appropriate
shell init file (e.g. <code>~/.zshrc</code> or <code>~/.bashrc</code>):</p>
<pre><code>PATH=$PATH:$HOME/local/gcc-arm-none-eabi-7-2017-q4-major/bin
</code></pre>
<a class="header" href="#optional-packages" id="optional-packages"><h2>Optional packages</h2></a>
<a class="header" href="#ubuntu--debian" id="ubuntu--debian"><h3>Ubuntu / Debian</h3></a>
<pre><code class="language-console">$ sudo apt-get install \
  bluez \
  rfkill
</code></pre>
<a class="header" href="#fedora" id="fedora"><h3>Fedora</h3></a>
<pre><code class="language-console">$ sudo dnf install \
  bluez \
  rfkill
</code></pre>
<a class="header" href="#arch-linux-1" id="arch-linux-1"><h3>Arch Linux</h3></a>
<pre><code class="language-console">$ sudo pacman -S \
  bluez \
  bluez-utils \
  rfkill
</code></pre>
<a class="header" href="#udev-rules" id="udev-rules"><h2>udev rules</h2></a>
<p>These rules let you use USB devices like the F3 and the Serial module without root privilege, i.e.
<code>sudo</code>.</p>
<p>Create these two files in <code>/etc/udev/rules.d</code> with the contents shown below.</p>
<pre><code class="language-console">$ cat /etc/udev/rules.d/99-ftdi.rules
</code></pre>
<pre><code class="language-text"># FT232 - USB &lt;-&gt; Serial Converter
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6001&quot;, MODE:=&quot;0666&quot;
</code></pre>
<pre><code class="language-console">$ cat /etc/udev/rules.d/99-openocd.rules
</code></pre>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;3748&quot;, MODE:=&quot;0666&quot;

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;374b&quot;, MODE:=&quot;0666&quot;
</code></pre>
<p>Then reload the udev rules with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload-rules
</code></pre>
<p>If you had any board plugged to your laptop, unplug them and then plug them in again.</p>
<p>Now, go to the <a href="verify.html">next section</a>.</p>
<a class="header" href="#windows" id="windows"><h1>Windows</h1></a>
<a class="header" href="#arm-none-eabi-gdb" id="arm-none-eabi-gdb"><h2><code>arm-none-eabi-gdb</code></h2></a>
<p>ARM provides <code>.exe</code> installers for Windows. Grab one from <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a>, and follow the instructions.
Just before the installation process finishes tick/select the &quot;Add path to environment variable&quot;
option. Then verify that the tools are in your <code>%PATH%</code>:</p>
<pre><code class="language-console">$ arm-none-eabi-gcc -v
(..)
gcc version 5.4.1 20160919 (release) (..)
</code></pre>
<a class="header" href="#openocd" id="openocd"><h2>OpenOCD</h2></a>
<p>There's no official binary release of OpenOCD for Windows but there are unofficial releases
available <a href="https://github.com/gnu-mcu-eclipse/openocd/releases">here</a>. Grab the 0.10.x zipfile and extract it somewhere in your drive (I
recommend <code>C:\OpenOCD</code> but with the drive letter that makes sense to you) then update your <code>%PATH%</code>
environment variable to include the following path: <code>C:\OpenOCD\bin</code> (or the path that you used
before).</p>
<p>Verify that OpenOCD is in yout <code>%PATH%</code> with:</p>
<pre><code class="language-console">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<a class="header" href="#putty" id="putty"><h2>PuTTY</h2></a>
<p>Download the latest <code>putty.exe</code> from <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">this site</a> and place it somewhere in your <code>%PATH%</code>.</p>
<a class="header" href="#st-link-usb-driver" id="st-link-usb-driver"><h2>ST-LINK USB driver</h2></a>
<p>You'll also need to install <a href="http://www.st.com/en/embedded-software/stsw-link009.html">this USB driver</a> or OpenOCD won't work. Follow the installer
instructions and make sure you install the right (32-bit or 64-bit) version of the driver.</p>
<p>That's all! Go to the <a href="verify.html">next section</a>.</p>
<a class="header" href="#macos" id="macos"><h1>macOS</h1></a>
<p>All the tools can be install using <a href="http://brew.sh/">Homebrew</a>:</p>
<pre><code class="language-console">$ brew cask install gcc-arm-embedded

$ brew install minicom openocd
</code></pre>
<p>If the <code>brew cask</code> command doesn't work (<code>Error: Unknown command: cask</code>), then run <code>brew tap Caskroom/tap</code> first and try again.</p>
<p>That's all! Go to the <a href="verify.html">next section</a>.</p>
<a class="header" href="#verify-the-installation" id="verify-the-installation"><h1>Verify the installation</h1></a>
<p>Let's verify that all the tools were installed correctly.</p>
<a class="header" href="#linux-only" id="linux-only"><h2>Linux only</h2></a>
<a class="header" href="#verify-permissions" id="verify-permissions"><h3>Verify permissions</h3></a>
<p>Connect the F3 to your laptop using an USB cable. Be sure to connect the cable to the &quot;USB ST-LINK&quot;
port, the USB port in the center of the edge of the board.</p>
<p>The F3 should now appear as a USB device (file) in <code>/dev/bus/usb</code>. Let's find out how it got
enumerated:</p>
<pre><code class="language-console">$ lsusb | grep -i stm
Bus 003 Device 004: ID 0483:374b STMicroelectronics ST-LINK/V2.1
$ # ^^^        ^^^
</code></pre>
<p>In my case, the F3 got connected to the bus #3 and got enumerated as the device #4. This means the
file <code>/dev/bus/usb/003/004</code> <em>is</em> the F3. Let's check its permissions:</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/003/004
crw-rw-rw- 1 root root 189, 20 Sep 13 00:00 /dev/bus/usb/003/004
</code></pre>
<p>The permissions should be <code>crw-rw-rw-</code>. If it's not ... then check your <a href="linux.html#udev-rules">udev
rules</a> and try re-loading them with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload-rules
</code></pre>
<p>Now let's repeat the procedure for the Serial module.</p>
<p>Unplug the F3 and plug the Serial module. Now, figure out what's its associated file:</p>
<pre><code class="language-console">$ lsusb | grep -i ft232
Bus 003 Device 005: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
</code></pre>
<p>In my case, it's the <code>/dev/bus/usb/003/005</code>. Now, check its permissions:</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/003/005
crw-rw-r-- 1 root root 189, 21 Sep 13 00:00 /dev/bus/usb/003/005
</code></pre>
<p>As before, the permissions should be <code>crw-rw-rw-</code>.</p>
<a class="header" href="#all" id="all"><h2>All</h2></a>
<a class="header" href="#first-openocd-connection" id="first-openocd-connection"><h3>First OpenOCD connection</h3></a>
<p>First, connect the F3 to your laptop using an USB cable. Connect the cable to the USB port in the
center of edge of the board, the one that's labeled &quot;USB ST-LINK&quot;.</p>
<p>Two <em>red</em> LEDs should turn on right after connecting the USB cable to the board.</p>
<p>Next, run this command:</p>
<pre><code class="language-console">$ # *nix
$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg

$ # Windows
$ # NOTE cygwin users have reported problems with the -s flag. If you run into
$ # that you can call openocd from the `C:\OpenOCD\share\scripts` directory
$ openocd -s C:\OpenOCD\share\scripts -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Windows users: <code>C:\OpenOCD</code> is the directory where you installed OpenOCD to.</p>
</blockquote>
<blockquote>
<p><strong>IMPORTANT</strong> There is more than one hardware revision of the STM32F3DISCOVERY board. For older
revisions, you'll need to change the &quot;interface&quot; argument to <code>-f interface/stlink-v2.cfg</code> (note:
no <code>-1</code> at the end). Alternatively, older revisions can use <code>-f board/stm32f3discovery.cfg</code>
instead of <code>-f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg</code>.</p>
</blockquote>
<p>You should see output like this:</p>
<pre><code class="language-console">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.915608
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>(If you don't ... then check the <a href="https://docs.rust-embedded.org/appendix/1-general-troubleshooting/index.html">general troubleshooting</a> instructions.)</p>
<p><code>openocd</code> will block the terminal. That's fine.</p>
<p>Also, one of the red LEDs, the one closest to the USB port, should start oscillating between red
light and green light.</p>
<p>That's it! It works. You can now close/kill <code>openocd</code>.</p>
<a class="header" href="#meet-your-hardware" id="meet-your-hardware"><h1>Meet your hardware</h1></a>
<p>Let's get familiar with the hardware we'll be working with.</p>
<a class="header" href="#stm32f3discovery-the-f3" id="stm32f3discovery-the-f3"><h2>STM32F3DISCOVERY (the &quot;F3&quot;)</h2></a>
<p align="center">
<img title="F3" src="https://docs.rust-embedded.org/assets/f3.jpg">
</p>
<p>We'll refer to this board as &quot;F3&quot; throughout this book.</p>
<p>What does this board contain?</p>
<ul>
<li>
<p>A STM32F303VCT6 microcontroller. This microcontroller has</p>
<ul>
<li>
<p>A single core ARM Cortex-M4F processor with hardware support for single precision floating point
operations and a maximum clock frequency of 72 MHz.</p>
</li>
<li>
<p>256 KiB of &quot;Flash&quot; memory. (1 KiB = 10<strong>24</strong> bytes)</p>
</li>
<li>
<p>48 KiB of RAM.</p>
</li>
<li>
<p>many &quot;peripherals&quot;: timers, GPIO, I2C, SPI, USART, etc.</p>
</li>
<li>
<p>lots of &quot;pins&quot; that are exposed in the two lateral &quot;headers&quot;.</p>
</li>
<li>
<p><strong>IMPORTANT</strong> This microcontroller operates at (around) 3.3V.</p>
</li>
</ul>
</li>
<li>
<p>An <a href="https://en.wikipedia.org/wiki/Accelerometer">accelerometer</a> and a <a href="https://en.wikipedia.org/wiki/Magnetometer">magnetometer</a> (in a single package).</p>
</li>
</ul>
<ul>
<li>A <a href="https://en.wikipedia.org/wiki/Gyroscope">gyroscope</a>.</li>
</ul>
<ul>
<li>
<p>8 user LEDs arranged in the shape of a compass</p>
</li>
<li>
<p>A second microcontroller: a STM32F103CBT. This microcontroller is actually part of an on-board
programmer and debugger named ST-LINK and is connected to the USB port named &quot;USB ST-LINK&quot;.</p>
</li>
<li>
<p>There's a second USB port, labeled &quot;USB USER&quot; that is connected to the main microcontroller, the
STM32F303VCT6, and can be used in applications.</p>
</li>
</ul>
<a class="header" href="#the-serial-module" id="the-serial-module"><h2>The Serial module</h2></a>
<p align="center">
<img title="Serial module" src="https://docs.rust-embedded.org/assets/serial.jpg">
</p>
<p>We'll use this module to exchange data between the microcontroller in the F3 and your laptop. This
module will be connected to your laptop using an USB cable. I won't say more at this point.</p>
<a class="header" href="#the-bluetooth-module" id="the-bluetooth-module"><h2>The Bluetooth module</h2></a>
<p align="center">
<img title="The HC-05 Bluetooth module" src="https://docs.rust-embedded.org/assets/bluetooth.jpg">
</p>
<p>This module has the exact same purpose as the serial module but it sends the data over Bluetooth
instead of over USB.</p>
<a class="header" href="#led-roulette" id="led-roulette"><h1>LED roulette</h1></a>
<p>Alright, let's start by building the following application:</p>
<p align="center">
<img src="https://i.imgur.com/0k1r2Lc.gif">
</p>
<p>I'm going to give you a high level API to implement this app but don't worry we'll do low level
stuff later on. The main goal of this chapter is to get familiar with the <em>flashing</em> and debugging
process.</p>
<p>Throughout this text we'll be using the starter code that's in the <a href="https://github.com/rust-embedded/discovery">discovery</a> repository. Make sure
you always have the latest version of the master branch because this website tracks that branch.</p>
<p>The starter code is in the <code>src</code> directory of that repository. Inside that directory there are more
directories named after each chapter of this book. Most of those directories are starter Cargo
projects.</p>
<p>Now, jump into the <code>src/05-led-roulette</code> directory. Check the <code>src/main.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::entry;

#[entry]
fn main() -&gt; ! {
    let _y;
    let x = 42;
    _y = x;

    // infinite loop; just so we don't leave this stack frame
    loop {}
}

</code></pre></pre>
<p>Microcontroller programs are different from standard programs in two aspects: <code>#![no_std]</code> and
<code>#![no_main]</code>.</p>
<p>The <code>no_std</code> attribute says that this program won't use the <code>std</code> crate, which assumes an underlying
OS; the program will instead use the <code>core</code> crate, a subset of <code>std</code> that can run on bare metal
systems (i.e., systems without OS abstractions like files and sockets).</p>
<p>The <code>no_main</code> attribute says that this program won't use the standard <code>main</code> interface, which is
tailored for command line applications that receive arguments. Instead of the standard <code>main</code> we'll
use the <code>entry</code> attribute from the <a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a> crate to define a custom entry point. In this
program we have named the entry point &quot;main&quot;, but any other name could have been used. The entry
point function must have signature <code>fn() -&gt; !</code>; this type indicates that the function can't return
-- this means that the program never terminates.</p>
<p>If you are a careful observer, you'll also notice there is a <code>.cargo</code> directory in the Cargo project
as well. This directory contains a Cargo configuration file (<code>.cargo/config</code>) that tweaks the
linking process to tailor the memory layout of the program to the requirements of the target device.
This modified linking process is a requirement of the <code>cortex-m-rt</code> crate.</p>
<p>Alright, let's start by building this program.</p>
<a class="header" href="#build-it" id="build-it"><h1>Build it</h1></a>
<p>The first step is to build our &quot;binary&quot; crate. Because the microcontroller has a different
architecture than your laptop we'll have to cross compile. Cross compiling in Rust land is as simple
as passing an extra <code>--target</code> flag to <code>rustc</code>or Cargo. The complicated part is figuring out the
argument of that flag: the <em>name</em> of the target.</p>
<p>The microcontroller in the F3 has a Cortex-M4F processor in it. <code>rustc</code> knows how to cross compile
to the Cortex-M architecture and provides 4 different targets that cover the different processor
families within that architecture:</p>
<ul>
<li><code>thumbv6m-none-eabi</code>, for the Cortex-M0 and Cortex-M1 processors</li>
<li><code>thumbv7m-none-eabi</code>, for the Cortex-M3 processor</li>
<li><code>thumbv7em-none-eabi</code>, for the Cortex-M4 and Cortex-M7 processors</li>
<li><code>thumbv7em-none-eabihf</code>, for the Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> processors</li>
</ul>
<p>For the F3, we'll to use the <code>thumbv7em-none-eabihf</code> target. Before cross compiling you have to
download pre-compiled version of the standard library (a reduced version of it actually) for your
target. That's done using <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<p>You only need to do the above step once; <code>rustup</code> will re-install a new standard library
(<code>rust-std</code> component) whenever you update your toolchain.</p>
<p>With the <code>rust-std</code> component in place you can now cross compile the program using Cargo:</p>
<pre><code class="language-console">$ # make sure you are in the `src/05-led-roulette` directory

$ cargo build --target thumbv7em-none-eabihf
   Compiling semver-parser v0.7.0
   Compiling aligned v0.1.1
   Compiling libc v0.2.35
   Compiling bare-metal v0.1.1
   Compiling cast v0.2.2
   Compiling cortex-m v0.4.3
   (..)
   Compiling stm32f30x v0.6.0
   Compiling stm32f30x-hal v0.1.2
   Compiling aux5 v0.1.0 (file://$PWD/aux)
   Compiling led-roulette v0.1.0 (file://$PWD)
    Finished dev [unoptimized + debuginfo] target(s) in 35.84 secs
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Be sure to compile this crate <em>without</em> optimizations. The provided Cargo.toml file and build command above will ensure optimizations are off.</p>
</blockquote>
<p>OK, now we have produced an executable. This executable won't blink any leds, it's just a simplified version that we will build upon later in the chapter. As a sanity check, let's verify that the produced executable is actually an ARM binary:</p>
<pre><code class="language-console">$ # equivalent to `readelf -h target/thumbv7em-none-eabihf/debug/led-roulette`
$ cargo readobj --target thumbv7em-none-eabihf --bin led-roulette -- -file-headers
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x8000197
  Start of program headers:          52 (bytes into file)
  Start of section headers:          740788 (bytes into file)
  Flags:                             0x5000400
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         20
  Section header string table index: 18
</code></pre>
<p>Next, we'll flash the program into our microcontroller.</p>
<a class="header" href="#flash-it" id="flash-it"><h1>Flash it</h1></a>
<p>Flashing is the process of moving our program into the microcontroller's (persistent) memory. Once
flashed, the microcontroller will execute the flashed program every time it is powered on.</p>
<p>In this case, our <code>led-roulette</code> program will be the <em>only</em> program in the microcontroller memory.
By this I mean that there's nothing else running on the microcontroller: no OS, no &quot;daemon&quot;,
nothing. <code>led-roulette</code> has full control over the device.</p>
<p>Onto the actual flashing. First thing we need is to do is launch OpenOCD. We did that in the
previous section but this time we'll run the command inside a temporary directory (<code>/tmp</code> on *nix;
<code>%TEMP%</code> on Windows).</p>
<p>Make sure the F3 is connected to your laptop and run the following commands on a new terminal.</p>
<pre><code class="language-console">$ # *nix
$ cd /tmp

$ # Windows
$ cd %TEMP%

$ # Windows: remember that you need an extra `-s %PATH_TO_OPENOCD%\share\scripts`
$ openocd \
  -f interface/stlink-v2-1.cfg \
  -f target/stm32f3x.cfg
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Older revisions of the board need to pass slightly different arguments to
<code>openocd</code>. Review <a href="https://docs.rust-embedded.org/03-setup/verify.html#first-openocd-connection">this section</a> for the details.</p>
</blockquote>
<p>The program will block; leave that terminal open.</p>
<p>Now it's a good time to explain what this command is actually doing.</p>
<p>I mentioned that the F3 actually has two microcontrollers. One of them is used as a
programmer/debugger. The part of the board that's used as a programmer is called ST-LINK (that's what
STMicroelectronics decided to call it). This ST-LINK is connected to the target microcontroller
using a Serial Wire Debug (SWD) interface (this interface is an ARM standard so you'll run into it
when dealing with other Cortex-M based microcontrollers). This SWD interface can be used to flash
and debug a microcontroller. The ST-LINK is connected to the &quot;USB ST-LINK&quot; port and will appear as
a USB device when you connect the F3 to your laptop.</p>
<p align="center">
<img height=640 title="On-board ST-LINK" src="https://docs.rust-embedded.org/assets/st-link.png">
</p>
<p>As for OpenOCD, it's software that provides some services like a <em>GDB server</em> on top of USB
devices that expose a debugging protocol like SWD or JTAG.</p>
<p>Onto the actual command: those <code>.cfg</code> files we are using instruct OpenOCD to look for a ST-LINK USB
device (<code>interface/stlink-v2-1.cfg</code>) and to expect a STM32F3XX microcontroller
(<code>target/stm32f3x.cfg</code>) to be connected to the ST-LINK.</p>
<p>The OpenOCD output looks like this:</p>
<pre><code class="language-console">Open On-Chip Debugger 0.9.0 (2016-04-27-23:18)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919073
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>The &quot;6 breakpoints, 4 watchpoints&quot; part indicates the debugging features the processor has
available.</p>
<p>Leave that <code>openocd</code> process running, and open a new terminal. Make sure that you are inside the project's <code>src/05-led-roulette/</code> directory.</p>
<p>I mentioned that OpenOCD provides a GDB server so let's connect to that right now:</p>
<pre><code class="language-console">$ &lt;gdb&gt; -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb)
</code></pre>
<p><strong>NOTE</strong>: <code>&lt;gdb&gt;</code> represents a GDB program capable of debugging ARM binaries.
This could be <code>arm-none-eabi-gdb</code>, <code>gdb-multiarch</code> or <code>gdb</code> depending on your
system -- you may have to try all three.</p>
<p>This only opens a GDB shell. To actually connect to the OpenOCD GDB server, use the following
command within the GDB shell:</p>
<pre><code>(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<p><strong>NOTE</strong>: If you are getting errors like <code>undefined debug reason 7 - target needs reset</code>, you can try running <code>monitor reset halt</code> as described <a href="https://stackoverflow.com/questions/38994596/reason-7-target-needs-reset-unreliable-debugging-setup">here</a>.</p>
<p><strong>NOTE</strong>: If the debugger is still not connecting to the OpenOCD server, then you may need to try using <code>arm-none-eabi-gdb</code> instead of the <code>gdb</code> command, as described above.</p>
<p>By default OpenOCD's GDB server listens on TCP port 3333 (localhost). This command is connecting to
that port.</p>
<p>After entering this command, you'll see new output in the OpenOCD terminal:</p>
<pre><code class="language-diff"> Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
+Info : accepting 'gdb' connection on tcp/3333
+Info : device id = 0x10036422
+Info : flash size = 256kbytes
</code></pre>
<p>Almost there. To flash the device, we'll use the <code>load</code> command inside the GDB shell:</p>
<pre><code>(gdb) load
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x38a lma 0x8000188
Loading section .rodata, size 0x8 lma 0x8000514
Start address 0x8000188, load size 1306
Transfer rate: 6 KB/sec, 435 bytes/write.
</code></pre>
<p>And that's it. You'll also see new output in the OpenOCD terminal.</p>
<pre><code class="language-diff"> Info : flash size = 256kbytes
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+adapter speed: 4000 kHz
+target state: halted
+target halted due to breakpoint, current mode: Thread
+xPSR: 0x61000000 pc: 0x2000003a msp: 0x2000a000
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
</code></pre>
<p>Our program is loaded, let's debug it!</p>
<a class="header" href="#debug-it" id="debug-it"><h1>Debug it</h1></a>
<p>We are already inside a debugging session so let's debug our program.</p>
<p>After the <code>load</code> command, our program is stopped at its <em>entry point</em>. This is indicated by the
&quot;Start address 0x8000XXX&quot; part of GDB's output. The entry point is the part of a program that a
processor / CPU will execute first.</p>
<p>The starter project I've provided to you has some extra code that runs <em>before</em> the <code>main</code> function.
At this time, we are not interested in that &quot;pre-main&quot; part so let's skip right to the beginning of
the <code>main</code> function. We'll do that using a breakpoint:</p>
<pre><code>(gdb) break main
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 10.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:10
10          let x = 42;
</code></pre>
<p>Breakpoints can be used to stop the normal flow of a program. The <code>continue</code> command will let the
program run freely <em>until</em> it reaches a breakpoint. In this case, until it reaches the <code>main</code>
function because there's a breakpoint there.</p>
<p>Note that GDB output says &quot;Breakpoint 1&quot;. Remember that our processor can only use six of these
breakpoints so it's a good idea to pay attention to these messages.</p>
<p>For a nicer debugging experience, we'll be using GDB's Text User Interface (TUI). To enter into that
mode, on the GDB shell enter the following command:</p>
<pre><code>(gdb) layout src
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Apologies Windows users. The GDB shipped with the GNU ARM Embedded Toolchain doesn't
support this TUI mode <code>:-(</code>.</p>
</blockquote>
<p><img src="https://docs.rust-embedded.org/assets/gdb-layout-src.png" alt="GDB session" title="GDB TUI" /></p>
<p>At any point you can leave the TUI mode using the following command:</p>
<pre><code>(gdb) tui disable
</code></pre>
<p>OK. We are now at the beginning of <code>main</code>. We can advance the program statement by statement using
the <code>step</code> command. So let's use that twice to reach the <code>_y = x</code> statement. Once you've typed <code>step</code>
once you can just hit enter to run it
again.</p>
<pre><code>(gdb) step
14           _y = x;
</code></pre>
<p>If you are not using the TUI mode, on each <code>step</code> call GDB will print back the current statement
along with its line number.</p>
<p>We are now &quot;on&quot; the <code>_y = x</code> statement; that statement hasn't been executed yet. This means that <code>x</code>
is initialized but <code>_y</code> is not. Let's inspect those stack/local variables using the <code>print</code> command:</p>
<pre><code>(gdb) print x
$1 = 42

(gdb) print &amp;x
$2 = (i32 *) 0x10001ff4

(gdb) print _y
$3 = -536810104

(gdb) print &amp;_y
$4 = (i32 *) 0x10001ff0
</code></pre>
<p>As expected, <code>x</code> contains the value <code>42</code>. <code>_y</code>, however, contains the value <code>-536810104</code> (?). Because
<code>_y</code> has not been initialized yet, it contains some garbage value.</p>
<p>The command <code>print &amp;x</code> prints the address of the variable <code>x</code>. The interesting bit here is that GDB
output shows the type of the reference: <code>i32*</code>, a pointer to an <code>i32</code> value. Another interesting
thing is that the addresses of <code>x</code> and <code>_y</code> are very close to each other: their addresses are just
<code>4</code> bytes apart.</p>
<p>Instead of printing the local variables one by one, you can also use the <code>info locals</code> command:</p>
<pre><code>(gdb) info locals
x = 42
_y = -536810104
</code></pre>
<p>OK. With another <code>step</code>, we'll be on top of the <code>loop {}</code> statement:</p>
<pre><code>(gdb) step
17          loop {}
</code></pre>
<p>And <code>_y</code> should now be initialized.</p>
<pre><code>(gdb) print _y
$5 = 42
</code></pre>
<p>If we use <code>step</code> again on top of the <code>loop {}</code> statement, we'll get stuck because the program will
never pass that statement. Instead, we'll switch to the disassemble view with the <code>layout asm</code>
command and advance one instruction at a time using <code>stepi</code>. You can always switch back into Rust
source code view later by issuing the <code>layout src</code> command again.</p>
<blockquote>
<p><strong>NOTE</strong> If you used the <code>step</code> command by mistake and GDB got stuck, you can get unstuck by hitting <code>Ctrl+C</code>.</p>
</blockquote>
<pre><code>(gdb) layout asm
</code></pre>
<p><img src="https://docs.rust-embedded.org/assets/gdb-layout-asm.png" alt="GDB session" title="GDB disassemble" /></p>
<p>If you are not using the TUI mode, you can use the <code>disassemble /m</code> command to disassemble the
program around the line you are currently at.</p>
<pre><code>(gdb) disassemble /m
Dump of assembler code for function main:
7       #[entry]
   0x08000188 &lt;+0&gt;:     sub     sp, #8
   0x0800018a &lt;+2&gt;:     movs    r0, #42 ; 0x2a

8       fn main() -&gt; ! {
9           let _y;
10          let x = 42;
   0x0800018c &lt;+4&gt;:     str     r0, [sp, #4]

11          _y = x;
   0x0800018e &lt;+6&gt;:     ldr     r0, [sp, #4]
   0x08000190 &lt;+8&gt;:     str     r0, [sp, #0]

12
13          // infinite loop; just so we don't leave this stack frame
14          loop {}
=&gt; 0x08000192 &lt;+10&gt;:    b.n     0x8000194 &lt;main+12&gt;
   0x08000194 &lt;+12&gt;:    b.n     0x8000194 &lt;main+12&gt;

End of assembler dump.
</code></pre>
<p>See the fat arrow <code>=&gt;</code> on the left side? It shows the instruction the processor will execute next.</p>
<p>If not inside the TUI mode on each <code>stepi</code> command GDB will print the statement, the line number
<em>and</em> the address of the instruction the processor will execute next.</p>
<pre><code>(gdb) stepi
0x08000194      14          loop {}

(gdb) stepi
0x08000194      14          loop {}
</code></pre>
<p>One last trick before we move to something more interesting. Enter the following commands into GDB:</p>
<pre><code>(gdb) monitor reset halt
Unable to match requested speed 1000 kHz, using 950 kHz
Unable to match requested speed 1000 kHz, using 950 kHz
adapter speed: 950 kHz
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x08000196 msp: 0x10002000

(gdb) continue
Continuing.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:10
10          let x = 42;
</code></pre>
<p>We are now back at the beginning of <code>main</code>!</p>
<p><code>monitor reset halt</code> will reset the microcontroller and stop it right at the program entry point.
The following <code>continue</code> command will let the program run freely until it reaches the <code>main</code>
function that has a breakpoint on it.</p>
<p>This combo is handy when you, by mistake, skipped over a part of the program that you were
interested in inspecting. You can easily roll back the state of your program back to its very
beginning.</p>
<blockquote>
<p><strong>The fine print</strong>: This <code>reset</code> command doesn't clear or touch RAM. That memory will retain its
values from the previous run. That shouldn't be a problem though, unless your program behavior
depends of the value of <em>uninitialized</em> variables but that's the definition of Undefined Behavior
(UB).</p>
</blockquote>
<p>We are done with this debug session. You can end it with the <code>quit</code> command.</p>
<pre><code>(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: $PWD/target/thumbv7em-none-eabihf/debug/led-roulette, Remote target
Ending remote debugging.
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If the default GDB CLI is not to your liking check out <a href="https://github.com/cyrus-and/gdb-dashboard#gdb-dashboard">gdb-dashboard</a>. It uses Python to
turn the default GDB CLI into a dashboard that shows registers, the source view, the assembly view
and other things.</p>
</blockquote>
<p>Don't close OpenOCD though! We'll use it again and again later on. It's better
just to leave it running.</p>
<p>What's next? The high level API I promised.</p>
<a class="header" href="#the-led-and-delay-abstractions" id="the-led-and-delay-abstractions"><h1>The <code>Led</code> and <code>Delay</code> abstractions</h1></a>
<p>Now, I'm going to introduce two high level abstractions that we'll use to implement the LED roulette
application.</p>
<p>The auxiliary crate, <code>aux5</code>, exposes an initialization function called <code>init</code>. When called this
function returns two values packed in a tuple: a <code>Delay</code> value and a <code>Leds</code> value.</p>
<p><code>Delay</code> can be used to block your program for a specified amount of milliseconds.</p>
<p><code>Leds</code> is actually an array of eight <code>Led</code>s. Each <code>Led</code> represents one of the LEDs on the F3 board,
and exposes two methods: <code>on</code> and <code>off</code> which can be used to turn the LED on or off, respectively.</p>
<p>Let's try out these two abstractions by modifying the starter code to look like this:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::{entry, prelude::*, Delay, Leds};

#[entry]
fn main() -&gt; ! {
    let (mut delay, mut leds): (Delay, Leds) = aux5::init();

    let half_period = 500_u16;

    loop {
        leds[0].on();
        delay.delay_ms(half_period);

        leds[0].off();
        delay.delay_ms(half_period);
    }
}
</code></pre></pre>
<p>Now build it:</p>
<pre><code class="language-console">$ cargo build --target thumbv7em-none-eabihf
</code></pre>
<blockquote>
<p><strong>NOTE</strong> It's possible to forget to rebuild the program <em>before</em> starting a GDB session; this
omission can lead to very confusing debug sessions. To avoid this problem you can call <code>cargo run</code>
instead of <code>cargo build</code>; <code>cargo run</code> will build <em>and</em> start a debug session ensuring you never
forget to recompile your program.</p>
</blockquote>
<p>Now, we'll repeat the flashing procedure that we did in the previous section:</p>
<pre><code class="language-console">$ # this starts a GDB session of the program; no need to specify the path to the binary
$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb) target remote :3333
Remote debugging using :3333
(..)

(gdb) load
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x3fc6 lma 0x8000188
Loading section .rodata, size 0xa0c lma 0x8004150
Start address 0x8000188, load size 19290
Transfer rate: 19 KB/sec, 4822 bytes/write.

(gdb) break main
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 9.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:9
9           let (mut delay, mut leds): (Delay, Leds) = aux5::init();
</code></pre>
<p>OK. Let's step through the code. This time, we'll use the <code>next</code> command instead of <code>step</code>. The
difference is that the <code>next</code> command will step <em>over</em> function calls instead of going inside them.</p>
<pre><code>(gdb) next
11          let half_period = 500_u16;

(gdb) next
13          loop {

(gdb) next
14              leds[0].on();

(gdb) next
15              delay.delay_ms(half_period);
</code></pre>
<p>After executing the <code>leds[0].on()</code> statement, you should see a red LED, the one pointing North,
turn on.</p>
<p>Let's continue stepping over the program:</p>
<pre><code>(gdb) next
17              leds[0].off();

(gdb) next
18              delay.delay_ms(half_period);
</code></pre>
<p>The <code>delay_ms</code> call will block the program for half a second but you may not notice because the
<code>next</code> command also takes some time to execute. However, after stepping over the <code>leds[0].off()</code>
statement you should see the red LED turn off.</p>
<p>You can already guess what this program does. Let it run uninterrupted using the <code>continue</code> command.</p>
<pre><code>(gdb) continue
Continuing.
</code></pre>
<p>Now, let's do something more interesting. We are going to modify the behavior of our program using
GDB.</p>
<p>First, let's stop the infinite loop by hitting <code>Ctrl+C</code>. You'll probably end up somewhere inside
<code>Led::on</code>, <code>Led::off</code> or <code>delay_ms</code>:</p>
<pre><code>Program received signal SIGINT, Interrupt.
0x080033f6 in core::ptr::read_volatile (src=0xe000e010) at /checkout/src/libcore/ptr.rs:472
472     /checkout/src/libcore/ptr.rs: No such file or directory.
</code></pre>
<p>In my case, the program stopped its execution inside a <code>read_volatile</code> function. GDB output shows
some interesting information about that: <code>core::ptr::read_volatile (src=0xe000e010)</code>. This means
that the function comes from the <code>core</code> crate and that it was called with argument <code>src = 0xe000e010</code>.</p>
<p>Just so you know, a more explicit way to show the arguments of a function is to use the <code>info args</code>
command:</p>
<pre><code>(gdb) info args
src = 0xe000e010
</code></pre>
<p>Regardless of where your program may have stopped you can always look at the output of the
<code>backtrace</code> command (<code>bt</code> for short) to learn how it got there:</p>
<pre><code>(gdb) backtrace
#0  0x080033f6 in core::ptr::read_volatile (src=0xe000e010)
    at /checkout/src/libcore/ptr.rs:472
#1  0x08003248 in &lt;vcell::VolatileCell&lt;T&gt;&gt;::get (self=0xe000e010)
    at $REGISTRY/vcell-0.1.0/src/lib.rs:43
#2  &lt;volatile_register::RW&lt;T&gt;&gt;::read (self=0xe000e010)
    at $REGISTRY/volatile-register-0.2.0/src/lib.rs:75
#3  cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
#4  0x08002d9c in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayUs&lt;u32&gt;&gt;::delay_us (self=0x10001fbc, us=500000)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:58
#5  0x08002cce in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u32&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:32
#6  0x08002d0e in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u16&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:38
#7  0x080001ee in main () at src/05-led-roulette/src/main.rs:18
</code></pre>
<p><code>backtrace</code> will print a trace of function calls from the current function down to main.</p>
<p>Back to our topic. To do what we are after, first, we have to return to the <code>main</code> function. We can
do that using the <code>finish</code> command. This command resumes the program execution and stops it again
right after the program returns from the current function. We'll have to call it several times.</p>
<pre><code>(gdb) finish
cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
124             self.csr.read() &amp; SYST_CSR_COUNTFLAG != 0
Value returned is $1 = 5

(gdb) finish
Run till exit from #0  cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (
    self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
0x08002d9c in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayUs&lt;u32&gt;&gt;::delay_us (
    self=0x10001fbc, us=500000)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:58
58              while !self.syst.has_wrapped() {}
Value returned is $2 = false

(..)

(gdb) finish
Run till exit from #0  0x08002d0e in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u16&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:38
0x080001ee in main () at src/05-led-roulette/src/main.rs:18
18              delay.delay_ms(half_period);
</code></pre>
<p>We are back in <code>main</code>. We have a local variable in here: <code>half_period</code></p>
<pre><code>(gdb) info locals
half_period = 500
delay = (..)
leds = (..)
</code></pre>
<p>Now, we are going to modify this variable using the <code>set</code> command:</p>
<pre><code>(gdb) set half_period = 100

(gdb) print half_period
$1 = 100
</code></pre>
<p>If you let program run free again using the <code>continue</code> command, you should see that the LED will
blink at a much faster rate now!</p>
<p>Question! What happens if you keep lowering the value of <code>half_period</code>? At what value of
<code>half_period</code> you can no longer see the LED blink?</p>
<p>Now, it's your turn to write a program.</p>
<a class="header" href="#the-challenge" id="the-challenge"><h1>The challenge</h1></a>
<p>You are now well armed to face a challenge! Your task will be to implement the application I showed
you at the beginning of this chapter.</p>
<p>Here's the GIF again:</p>
<p align="center">
<img src="https://i.imgur.com/0k1r2Lc.gif">
</p>
<p>Also, this may help:</p>
<p align="center">
<img src="https://docs.rust-embedded.org/assets/timing-diagram.png">
</p>
<p>This is a timing diagram. It indicates which LED is on at any given instant of time and for how long
each LED should be on. On the X axis we have the time in milliseconds. The timing diagram shows a
single period. This pattern will repeat itself every 800 ms. The Y axis labels each LED with a
cardinal point: North, East, etc. As part of the challenge you'll have to figure out how each
element in the <code>Leds</code> array maps to these cardinal points (hint: <code>cargo doc --open</code> <code>;-)</code>).</p>
<p>Before you attempt this challenge, let me give you one last tip. Our GDB sessions always involve
entering the same commands at the beginning. We can use a <code>.gdb</code> file to execute some commands
right after GDB is started. This way you can save yourself the effort of having to enter them
manually on each GDB session.</p>
<p>Place this <code>openocd.gdb</code> file in the root of the Cargo project, right next to the <code>Cargo.toml</code>:</p>
<pre><code class="language-console">$ cat openocd.gdb
</code></pre>
<pre><code class="language-text">target remote :3333
load
break main
continue
</code></pre>
<p>Then modify the second line of the <code>.cargo/config</code> file:</p>
<pre><code class="language-console">$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7em-none-eabihf]
runner = &quot;arm-none-eabi-gdb -q -x openocd.gdb&quot; # &lt;-
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
]
</code></pre>
<p>With that in place, you should now be able to start a <code>gdb</code> session that will automatically flash
the program and jump to the beginning of <code>main</code>:</p>
<pre><code class="language-console">$ cargo run --target thumbv7em-none-eabihf
     Running `arm-none-eabi-gdb -q -x openocd.gdb target/thumbv7em-none-eabihf/debug/led-roulette`
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(..)
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x3b20 lma 0x8000188
Loading section .rodata, size 0xb0c lma 0x8003cc0
Start address 0x8003b1c, load size 18356
Transfer rate: 20 KB/sec, 6118 bytes/write.
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 9.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:9
9           let (mut delay, mut leds): (Delay, Leds) = aux5::init();
(gdb)
</code></pre>
<a class="header" href="#my-solution" id="my-solution"><h1>My solution</h1></a>
<p>What solution did you come up with?</p>
<p>Here's mine:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::{entry, prelude::*, Delay, Leds};

#[entry]
fn main() -&gt; ! {
    let (mut delay, mut leds): (Delay, Leds) = aux5::init();

    let ms = 50_u8;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay.delay_ms(ms);
            leds[curr].off();
            delay.delay_ms(ms);
        }
    }
}

</code></pre></pre>
<p>One more thing! Check that your solution also works when compiled in &quot;release&quot; mode:</p>
<pre><code class="language-console">$ cargo build --target thumbv7em-none-eabihf --release
</code></pre>
<p>You can test it with this <code>gdb</code> command:</p>
<pre><code class="language-console">$ # or, you could simply call `cargo run --target thumbv7em-none-eabihf --release`
$ arm-none-eabi-gdb target/thumbv7em-none-eabihf/release/led-roulette
$ #                                              ~~~~~~~
</code></pre>
<p>Binary size is something we should always keep an eye on! How big is your solution? You can check
that using the <code>size</code> command on the release binary:</p>
<pre><code class="language-console">$ # equivalent to size target/thumbv7em-none-eabihf/debug/led-roulette
$ cargo size --target thumbv7em-none-eabihf --bin led-roulette -- -A
led-roulette  :
section               size        addr
.vector_table          392   0x8000000
.text                16404   0x8000188
.rodata               2924   0x80041a0
.data                    0  0x20000000
.bss                     4  0x20000000
.debug_str          602185         0x0
.debug_abbrev        24134         0x0
.debug_info         553143         0x0
.debug_ranges       112744         0x0
.debug_macinfo          86         0x0
.debug_pubnames      56467         0x0
.debug_pubtypes      94866         0x0
.ARM.attributes         58         0x0
.debug_frame        174812         0x0
.debug_line         354866         0x0
.debug_loc             534         0x0
.comment                75         0x0
Total              1993694

$ cargo size --target thumbv7em-none-eabihf --bin led-roulette --release -- -A
led-roulette  :
section              size        addr
.vector_table         392   0x8000000
.text                1826   0x8000188
.rodata                84   0x80008ac
.data                   0  0x20000000
.bss                    4  0x20000000
.debug_str          23334         0x0
.debug_loc           6964         0x0
.debug_abbrev        1337         0x0
.debug_info         40582         0x0
.debug_ranges        2936         0x0
.debug_macinfo          1         0x0
.debug_pubnames      5470         0x0
.debug_pubtypes     10016         0x0
.ARM.attributes        58         0x0
.debug_frame          164         0x0
.debug_line          9081         0x0
.comment               18         0x0
Total              102267
</code></pre>
<blockquote>
<p><strong>NOTE</strong> The Cargo project is already configured to build the release binary using LTO.</p>
</blockquote>
<p>Know how to read this output? The <code>text</code> section contains the program instructions. It's around 2KB
in my case. On the other hand, the <code>data</code> and <code>bss</code> sections contain variables statically allocated
in RAM (<code>static</code> variables). A <code>static</code> variable is being used in <code>aux5::init</code>; that's why it shows 4
bytes of <code>bss</code>.</p>
<p>One final thing! We have been running our programs from within GDB but our programs don't depend on
GDB at all. You can confirm this be closing both GDB and OpenOCD and then resetting the board by
pressing the black button on the board. The LED roulette application will run without intervention
of GDB.</p>
<a class="header" href="#hello-world" id="hello-world"><h1>Hello, world!</h1></a>
<blockquote>
<p><strong>HEADS UP</strong> Several readers have reported that the &quot;solder bridge&quot; SB10 (see back of the board)
on the STM32F3DISCOVERY, which is required to use the ITM and the <code>iprint!</code> macros shown below, is
<strong>not</strong> soldered even though the <a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">User Manual</a> (page 21) says that it <strong>should be</strong>.</p>
</blockquote>
<blockquote>
<p><strong>TL;DR</strong> You have two options to fix this: Either <strong>solder</strong> the solder bridge SB10 or connect a
wire between SWO and PB3 as shown in the picture below.</p>
</blockquote>
<p align="center">
<img height=640 title="Manual SWD connection" src="https://docs.rust-embedded.org/assets/f3-swd.png">
</p>
<hr />
<p>Just a little more of helpful magic before we start doing low level stuff.</p>
<p>Blinking an LED is like the &quot;Hello, world&quot; of the embedded world.</p>
<p>But in this section, we'll run a proper &quot;Hello, world&quot; program that prints stuff to your laptop
console.</p>
<p>Go to the <code>06-hello-world</code> directory. There's some starter code in it:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux6::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let mut itm = aux6::init();

    iprintln!(&amp;mut itm.stim[0], &quot;Hello, world!&quot;);

    loop {}
}

</code></pre></pre>
<p>The <code>iprintln</code> macro will format messages and output them to the microcontroller's <em>ITM</em>. ITM stands
for Instrumentation Trace Macrocell and it's a communication protocol on top of SWD (Serial Wire
Debug) which can be used to send messages from the microcontroller to the debugging host. This
communication is only <em>one way</em>: the debugging host can't send data to the microcontroller.</p>
<p>OpenOCD, which is managing the debug session, can receive data sent through this ITM <em>channel</em> and
redirect it to a file.</p>
<p>The ITM protocol works with <em>frames</em> (you can think of them as Ethernet frames). Each frame has a
header and a variable length payload. OpenOCD will receive these frames and write them directly to a
file without parsing them. So, if the microntroller sends the string &quot;Hello, world!&quot; using the
<code>iprintln</code> macro, OpenOCD's output file won't exactly contain that string.</p>
<p>To retrieve the original string, OpenOCD's output file will have to be parsed. We'll use the
<code>itmdump</code> program to perform the parsing as new data arrives.</p>
<p>You should have already installed the <code>itmdump</code> program during the <a href="https://docs.rust-embedded.org/03-setup/index.html#i.html">installation chapter</a>.</p>
<p>In a new terminal, run this command inside the <code>/tmp</code> directory, if you are using a *nix OS, or from
within the <code>%TEMP%</code> directory, if you are running Windows. This should be the same directory from
where you are running OpenOCD.</p>
<blockquote>
<p><strong>NOTE</strong> It's very important that both <code>itmdump</code> and <code>openocd</code> are running
from the same directory!</p>
</blockquote>
<pre><code class="language-console">$ # itmdump terminal

$ # *nix
$ cd /tmp &amp;&amp; touch itm.txt

$ # Windows
$ cd %TEMP% &amp;&amp; type nul &gt;&gt; itm.txt

$ # both
$ itmdump -F -f itm.txt
</code></pre>
<p>This command will block as <code>itmdump</code> is now watching the <code>itm.txt</code> file. Leave this terminal open.</p>
<p>Alright. Now, let's build the starter code and flash it into the microcontroller.</p>
<p>To avoid passing the <code>--target thumbv7em-none-eabihf</code> flag to every Cargo invocation we can set a
default target in .cargo/config:</p>
<pre><code class="language-diff"> [target.thumbv7em-none-eabihf]
 runner = &quot;arm-none-eabi-gdb -q -x openocd.gdb&quot;
 rustflags = [
   &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
 ]

+[build]
+target = &quot;thumbv7em-none-eabihf&quot;
</code></pre>
<p>Now if <code>--target</code> is not specified Cargo will assume that the target is <code>thumbv7em-none-eabihf</code>.</p>
<pre><code class="language-console">$ cargo run
Reading symbols from target/thumbv7em-none-eabihf/debug/hello-world...done.
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x27c4 lma 0x8000400
Loading section .rodata, size 0x744 lma 0x8002be0
Start address 0x8002980, load size 13064
Transfer rate: 18 KB/sec, 4354 bytes/write.
Breakpoint 1 at 0x8000402: file src/06-hello-world/src/main.rs, line 10.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/06-hello-world/src/main.rs:10
10          let mut itm = aux6::init();
</code></pre>
<p>Note that there's a <code>openocd.gdb</code> at the root of the Cargo project. It's pretty similar to the one we
used in the previous section.</p>
<p>Before we execute the <code>iprintln!</code> statement. We have to instruct OpenOCD to redirect the ITM output
into the same file that <code>itmdump</code> is watching.</p>
<pre><code>(gdb) # globally enable the ITM and redirect all output to itm.txt
(gdb) monitor tpiu config internal itm.txt uart off 8000000

(gdb) # enable the ITM port 0
(gdb) monitor itm port 0 on
</code></pre>
<p>All should be ready! Now execute the <code>iprintln!</code> statement.</p>
<pre><code>(gdb) next
12          iprintln!(&amp;mut itm.stim[0], &quot;Hello, world!&quot;);

(gdb) next
14          loop {}
</code></pre>
<p>You should see some output in the <code>itmdump</code> terminal:</p>
<pre><code class="language-console">$ itmdump -F -f itm.txt
(..)
Hello, world!
</code></pre>
<p>Awesome, right? Feel free to use <code>iprintln</code> as a logging tool in the coming sections.</p>
<p>Next: That's not all! The <code>iprint!</code> macros are not the only thing that uses the ITM. <code>:-)</code></p>
<a class="header" href="#panic" id="panic"><h1><code>panic!</code></h1></a>
<p>The <code>panic!</code> macro also sends its output to the ITM!</p>
<p>Change the <code>main</code> function to look like this:</p>
<pre><pre class="playpen"><code class="language-rust">#[entry]
fn main() -&gt; ! {
    panic!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Let's try this program. But before that let's update <code>openocd.gdb</code> to run that <code>monitor</code> stuff for
us during GDB startup:</p>
<pre><code class="language-diff"> target remote :3333
 set print asm-demangle on
 set print pretty on
 load
+monitor tpiu config internal itm.txt uart off 8000000
+monitor itm port 0 on
 break main
 continue
</code></pre>
<p>OK, now run it.</p>
<pre><code class="language-console">$ cargo run
(..)
Breakpoint 1, main () at src/06-hello-world/src/main.rs:10
10          panic!(&quot;Hello, world!&quot;);

(gdb) next
</code></pre>
<p>You'll see some new output in the <code>itmdump</code> terminal.</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
panicked at 'Hello, world!', src/06-hello-world/src/main.rs:10:5
</code></pre>
<!-- FIXME backtraces appear to be broken? -->
<!-- You won't get a `RUST_BACKTRACE` style backtrace in `itmdump`'s output, *but* -->
<!-- you can get the equivalent inside GDB. You already know the command: -->
<!-- ``` -->
<!-- (gdb) backtrace -->
<!-- #0  __bkpt () at asm/bkpt.s:3 -->
<!-- #1  0x08000224 in cortex_m::asm::bkpt () -->
<!--     at $REGISTRY/cortex-m-0.5.2/src/asm.rs:19 -->
<!-- #2  rust_begin_unwind (info=0x10001f84) at src/06-hello-world/auxiliary/src/lib.rs:31 -->
<!-- #3  0x08002548 in core::panicking::panic_fmt () at libcore/panicking.rs:92 -->
<!-- #4  0x080024d8 in core::panicking::panic () at libcore/panicking.rs:53 -->
<!-- #5  0x08000194 in hello_world::main () at src/06-hello-world/src/main.rs:14 -->
<!-- ``` -->
<!-- Ultimately, `panic!` is just another function call so you can see it leaves behind a trace of -->
<!-- function calls. -->
<p>Another thing you can do is catch the panic <em>before</em> it does the logging by
putting a breakpoint on the <code>rust_begin_unwind</code> symbol.</p>
<pre><code>(gdb) monitor reset halt
(..)
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x080026ba msp: 0x10002000

(gdb) break rust_begin_unwind
Breakpoint 2 at 0x80011d2: file $REGISTRY/panic-itm-0.4.0/src/lib.rs, line 46.

(gdb) continue
Continuing.

Breakpoint 2, rust_begin_unwind (info=0x10001fac) at $REGISTRY/panic-itm-0.4.0/src/lib.rs:46
46          interrupt::disable();
</code></pre>
<p>You'll notice that nothing got printed on the <code>itmdump</code> console this time. If
you resume the program using <code>continue</code> then a new line will be printed.</p>
<p>In a later section we'll look into other simpler communication protocols.</p>
<a class="header" href="#registers" id="registers"><h1>Registers</h1></a>
<p>It's time to explore what the <code>Led</code> API does under the hood.</p>
<p>In a nutshell, it just writes to some special memory regions. Go into the <code>07-registers</code> directory
and let's run the starter code statement by statement.</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        // A magic address!
        const GPIOE_BSRR: u32 = 0x48001018;

        // Turn on the &quot;North&quot; LED (red)
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

        // Turn on the &quot;East&quot; LED (green)
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

        // Turn off the &quot;North&quot; LED
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);

        // Turn off the &quot;East&quot; LED
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
    }

    loop {}
}

</code></pre></pre>
<p>What's this magic?</p>
<p>The address <code>0x48001018</code> points to a <em>register</em>. A register is a special region of memory that
controls a <em>peripheral</em>. A peripheral is a piece of electronics that sits right next to the
processor within the microcontroller package and provides the processor with extra functionality.
After all, the processor, on its own, can only do math and logic.</p>
<p>This particular register controls General Purpose Input/Output (GPIO) <em>pins</em> (GPIO <em>is</em> a
peripheral) and can be used to <em>drive</em> each of those pins <em>low</em> or <em>high</em>.</p>
<a class="header" href="#an-aside-leds-digital-outputs-and-voltage-levels" id="an-aside-leds-digital-outputs-and-voltage-levels"><h2>An aside: LEDs, digital outputs and voltage levels</h2></a>
<p>Drive? Pin? Low? High?</p>
<p>A pin is a electrical contact. Our microcontroller has several of them and some of them are
connected to LEDs. An LED, a Light Emitting Diode, will only emit light when voltage is applied to
it with a certain polarity.</p>
<p align="center">
<img height=180 title="LED circuit" src="https://upload.wikimedia.org/wikipedia/commons/c/c9/LED_circuit.svg">
</p>
<p>Luckily for us, the microcontroller's pins are connected to the LEDs with the right polarity. All
that we have to do is <em>output</em> some non-zero voltage through the pin to turn the LED on. The pins
attached to the LEDs are configured as <em>digital outputs</em> and can only output two different voltage
levels: &quot;low&quot;, 0 Volts, or &quot;high&quot;, 3 Volts. A &quot;high&quot; (voltage) level will turn the LED on whereas
a &quot;low&quot; (voltage) level will turn it off.</p>
<p>These &quot;low&quot; and &quot;high&quot; states map directly to the concept of digital logic. &quot;low&quot; is <code>0</code> or <code>false</code>
and &quot;high&quot; is <code>1</code> or <code>true</code>. This is why this pin configuration is known as digital output.</p>
<hr />
<p>OK. But how can one find out what this register does? Time to RTRM (Read the Reference Manual)!</p>
<a class="header" href="#rtrm-reading-the-reference-manual" id="rtrm-reading-the-reference-manual"><h1>RTRM: Reading The Reference Manual</h1></a>
<p>I mentioned that the microcontroller has several pins. For convenience, these pins are grouped in
<em>ports</em> of 16 pins. Each port is named with a letter: Port A, Port B, etc. and the pins within each
port are named with numbers from 0 to 15.</p>
<p>The first thing we have to find out is which pin is connected to which LED. This information is in
the STM32F3DISCOVERY <a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">User Manual</a> (You downloaded a copy, right?). In this particular section:</p>
<blockquote>
<p>Section 6.4 LEDs - Page 18</p>
</blockquote>
<p>The manual says:</p>
<ul>
<li><code>LD3</code>, the North LED, is connected to the pin <code>PE9</code>. <code>PE9</code> is the short form of: Pin 9 on Port E.</li>
<li><code>LD7</code>, the East LED, is connected to the pin <code>PE11</code>.</li>
</ul>
<p>Up to this point, we know that we want to change the state of the pins PE9 and PE11 to turn the
North/East LEDs on/off. These pins are part of Port E so we'll have to deal with the <code>GPIOE</code>
peripheral.</p>
<p>Each peripheral has a register <em>block</em> associated to it. A register block is a collection of
registers allocated in contiguous memory. The address at which the register block starts is known as
its base address. We need to figure out what's the base address of the <code>GPIOE</code> peripheral. That
information is in the following section of the microcontroller <a href="http://www.st.com/resource/en/reference_manual/dm00043574.pdf">Reference Manual</a>:</p>
<blockquote>
<p>Section 3.2.2 Memory map and register boundary addresses - Page 51</p>
</blockquote>
<p>The table says that base address of the <code>GPIOE</code> register block is <code>0x4800_1000</code>.</p>
<p>Each peripheral also has its own section in the documentation. Each of these sections ends with a
table of the registers that the peripheral's register block contains. For the <code>GPIO</code> family of
peripheral, that table is in:</p>
<blockquote>
<p>Section 11.4.12 GPIO register map - Page 243</p>
</blockquote>
<p>We are interested in the register that's at an offset of <code>0x18</code> from the base address of the <code>GPIOE</code>
peripheral. According to the table, that would be the register <code>BSRR</code>.</p>
<p>Now we need to jump to the documentation of that particular register. It's a few pages above in:</p>
<blockquote>
<p>Section 11.4.7 GPIO port bit set/reset register (GPIOx_BSRR) - Page 240</p>
</blockquote>
<p>Finally!</p>
<p>This is the register we were writing to. The documentation says some interesting things. First, this
register is write only ... so let's try reading its value <code>:-)</code>.</p>
<p>We'll use GDB's <code>examine</code> command: <code>x</code>.</p>
<pre><code>(gdb) next
16              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

(gdb) x 0x48001018
0x48001018:     0x00000000

(gdb) # the next command will turn the North LED on
(gdb) next
19              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

(gdb) x 0x48001018
0x48001018:     0x00000000
</code></pre>
<p>Reading the register returns <code>0</code>. That matches what the documentation says.</p>
<p>The other thing that the documentation says is that the bits 0 to 15 can be used to <em>set</em> the
corresponding pin. That is bit 0 sets the pin 0. Here, <em>set</em> means outputting a <em>high</em> value on
the pin.</p>
<p>The documentation also says that bits 16 to 31 can be used to <em>reset</em> the corresponding pin. In this
case, the bit 16 resets the pin number 0. As you may guess, <em>reset</em> means outputting a <em>low</em> value
on the pin.</p>
<p>Correlating that information with our program, all seems to be in agreement:</p>
<ul>
<li>
<p>Writing <code>1 &lt;&lt; 9</code> (<code>BS9 = 1</code>)  to <code>BSRR</code>  sets <code>PE9</code> <em>high</em>. That turns the North LED <em>on</em>.</p>
</li>
<li>
<p>Writing <code>1 &lt;&lt; 11</code> (<code>BS11 = 1</code>) to <code>BSRR</code> sets <code>PE11</code> <em>high</em>. That turns the East LED <em>on</em>.</p>
</li>
<li>
<p>Writing <code>1 &lt;&lt; 25</code> (<code>BR9 = 1</code>) to <code>BSRR</code> sets <code>PE9</code> <em>low</em>. That turns the North LED <em>off</em>.</p>
</li>
<li>
<p>Finally, writing <code>1 &lt;&lt; 27</code> (<code>BR11 = 1</code>) to <code>BSRR</code> sets <code>PE11</code> <em>low</em>. That turns the East LED <em>off</em>.</p>
</li>
</ul>
<a class="header" href="#misoptimization" id="misoptimization"><h1>(mis)Optimization</h1></a>
<p>Reads/writes to registers are quite special. I may even dare to say that they are embodiment of side
effects. In the previous example we wrote four different values to the same register. If you didn't
know that address was a register, you may have simplified the logic to just write the final value <code>1 &lt;&lt; (11 + 16)</code> into the register.</p>
<p>Actually, LLVM, the compiler's backend / optimizer, does not know we are dealing with a register and
will merge the writes thus changing the behavior of our program. Let's check that really quick.</p>
<pre><code class="language-console">$ cargo run --release
(..)
Breakpoint 1, main () at src/07-registers/src/main.rs:9
9           aux7::init();

(gdb) next
25              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);

(gdb) disassemble /m
Dump of assembler code for function main:
7       #[entry]

8       fn main() -&gt; ! {
9           aux7::init();
   0x08000188 &lt;+0&gt;:     bl      0x800019c &lt;aux7::init&gt;
   0x0800018c &lt;+4&gt;:     movw    r0, #4120       ; 0x1018
   0x08000190 &lt;+8&gt;:     mov.w   r1, #134217728  ; 0x8000000
   0x08000194 &lt;+12&gt;:    movt    r0, #18432      ; 0x4800

10
11          unsafe {
12              // A magic address!
13              const GPIOE_BSRR: u32 = 0x48001018;
14
15              // Turn on the &quot;North&quot; LED (red)
16              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;
17
18              // Turn on the &quot;East&quot; LED (green)
19              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;
20
21              // Turn off the &quot;North&quot; LED
22              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
23
24              // Turn off the &quot;East&quot; LED
25              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
=&gt; 0x08000198 &lt;+16&gt;:    str     r1, [r0, #0]

26          }
27
28          loop {}
   0x0800019a &lt;+18&gt;:    b.n     0x800019a &lt;main+18&gt;

End of assembler dump.
</code></pre>
<p>The state of the LEDs didn't change this time! The <code>str</code> instruction is the one that writes a value
to the register. Our <em>debug</em> (unoptimized) program had four of them, one for each write to the
register, but the <em>release</em> (optimized) program only has one.</p>
<p>We can check that using <code>objdump</code>:</p>
<pre><code class="language-console">$ # same as cargo objdump -- -d -no-show-raw-insn -print-imm-hex -source target/thumbv7em-none-eabihf/debug/registers
$ cargo objdump --bin registers -- -d -no-show-raw-insn -print-imm-hex -source
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
; #[entry]
 8000188:       sub     sp, #0x18
; aux7::init();
 800018a:       bl      #0xbc
 800018e:       str     r0, [sp, #0x14]
 8000190:       b       #-0x2 &lt;main+0xa&gt;
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;
 8000192:       b       #-0x2 &lt;main+0xc&gt;
 8000194:       movw    r0, #0x1018
 8000198:       movt    r0, #0x4800
 800019c:       mov.w   r1, #0x200
 80001a0:       str     r1, [r0]
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;
 80001a2:       b       #-0x2 &lt;main+0x1c&gt;
 80001a4:       movw    r0, #0x1018
 80001a8:       movt    r0, #0x4800
 80001ac:       mov.w   r1, #0x800
 80001b0:       str     r1, [r0]
 80001b2:       movs    r0, #0x19
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
 80001b4:       mov     r1, r0
 80001b6:       cmp     r0, #0x9
 80001b8:       str     r1, [sp, #0x10]
 80001ba:       bvs     #0x54 &lt;main+0x8a&gt;
 80001bc:       b       #-0x2 &lt;main+0x36&gt;
 80001be:       ldr     r0, [sp, #0x10]
 80001c0:       and     r1, r0, #0x1f
 80001c4:       movs    r2, #0x1
 80001c6:       lsl.w   r1, r2, r1
 80001ca:       lsrs    r2, r0, #0x5
 80001cc:       cmp     r2, #0x0
 80001ce:       str     r1, [sp, #0xc]
 80001d0:       bne     #0x4c &lt;main+0x98&gt;
 80001d2:       b       #-0x2 &lt;main+0x4c&gt;
 80001d4:       movw    r0, #0x1018
 80001d8:       movt    r0, #0x4800
 80001dc:       ldr     r1, [sp, #0xc]
 80001de:       str     r1, [r0]
 80001e0:       movs    r0, #0x1b
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
 80001e2:       mov     r2, r0
 80001e4:       cmp     r0, #0xb
 80001e6:       str     r2, [sp, #0x8]
 80001e8:       bvs     #0x42 &lt;main+0xa6&gt;
 80001ea:       b       #-0x2 &lt;main+0x64&gt;
 80001ec:       ldr     r0, [sp, #0x8]
 80001ee:       and     r1, r0, #0x1f
 80001f2:       movs    r2, #0x1
 80001f4:       lsl.w   r1, r2, r1
 80001f8:       lsrs    r2, r0, #0x5
 80001fa:       cmp     r2, #0x0
 80001fc:       str     r1, [sp, #0x4]
 80001fe:       bne     #0x3a &lt;main+0xb4&gt;
 8000200:       b       #-0x2 &lt;main+0x7a&gt;
 8000202:       movw    r0, #0x1018
 8000206:       movt    r0, #0x4800
 800020a:       ldr     r1, [sp, #0x4]
 800020c:       str     r1, [r0]
; loop {}
 800020e:       b       #-0x2 &lt;main+0x88&gt;
 8000210:       b       #-0x4 &lt;main+0x88&gt;
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
 8000212:       movw    r0, #0x41bc
 8000216:       movt    r0, #0x800
 800021a:       bl      #0x3b28
 800021e:       trap
 8000220:       movw    r0, #0x4204
 8000224:       movt    r0, #0x800
 8000228:       bl      #0x3b1a
 800022c:       trap
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
 800022e:       movw    r0, #0x421c
 8000232:       movt    r0, #0x800
 8000236:       bl      #0x3b0c
 800023a:       trap
 800023c:       movw    r0, #0x4234
 8000240:       movt    r0, #0x800
 8000244:       bl      #0x3afe
 8000248:       trap
</code></pre>
<p>How do we prevent LLVM from misoptimizing our program? We use <em>volatile</em> operations instead of plain
reads/writes:</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        // A magic address!
        const GPIOE_BSRR: u32 = 0x48001018;

        // Turn on the &quot;North&quot; LED (red)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        // Turn on the &quot;East&quot; LED (green)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        // Turn off the &quot;North&quot; LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        // Turn off the &quot;East&quot; LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}
</code></pre></pre>
<p>If we look at the disassembly of this new program compiled in release mode:</p>
<pre><code class="language-console">$ cargo objdump --bin registers --release -- -d -no-show-raw-insn -print-imm-hex -source
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
; #[entry]
 8000188:       bl      #0x22
; aux7::init();
 800018c:       movw    r0, #0x1018
 8000190:       mov.w   r1, #0x200
 8000194:       movt    r0, #0x4800
 8000198:       str     r1, [r0]
 800019a:       mov.w   r1, #0x800
 800019e:       str     r1, [r0]
 80001a0:       mov.w   r1, #0x2000000
 80001a4:       str     r1, [r0]
 80001a6:       mov.w   r1, #0x8000000
 80001aa:       str     r1, [r0]
; loop {}
 80001ac:       b       #-0x4 &lt;main+0x24&gt;
</code></pre>
<p>We see that the four writes (<code>str</code> instructions) are preserved. If you run it (use <code>stepi</code>), you'll
also see that behavior of the program is preserved.</p>
<a class="header" href="#a0xbaaaaaad-address" id="a0xbaaaaaad-address"><h1><code>0xBAAAAAAD</code> address</h1></a>
<p>Not all the peripheral memory can be accessed. Look at this program.</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        ptr::read_volatile(0x4800_1800 as *const u32);
    }

    loop {}
}
</code></pre></pre>
<p>This address is close to the <code>GPIOE_BSRR</code> address we used before but this address is <em>invalid</em>.
Invalid in the sense that there's no register at this address.</p>
<p>Now, let's try it.</p>
<pre><code class="language-console">$ cargo run
Breakpoint 3, main () at src/07-registers/src/main.rs:9
9           aux7::init();

(gdb) continue
Continuing.

Breakpoint 2, UserHardFault_ (ef=0x10001fc0)
    at $REGISTRY/cortex-m-rt-0.6.3/src/lib.rs:535
535         loop {
</code></pre>
<p>We tried to do an invalid operation, reading memory that doesn't exist, so the processor raised an
<em>exception</em>, a <em>hardware</em> exception.</p>
<p>In most cases, exceptions are raised when the processor attempts to perform an invalid operation.
Exceptions break the normal flow of a program and force the processor to execute an <em>exception
handler</em>, which is just a function/subroutine.</p>
<p>There are different kind of exceptions. Each kind of exception is raised by different conditions and
each one is handled by a different exception handler.</p>
<p>The <code>aux7</code> crate depends on the <code>cortex-m-rt</code> crate which defines a default
<em>hard fault</em> handler, named <code>UserHardFault</code>, that handles the &quot;invalid memory
address&quot; exception. <code>openocd.gdb</code> placed a breakpoint on <code>HardFault</code>; that's why
the debugger halted your program while it was executing the exception handler.
We can get more information about the exception from the debugger. Let's see:</p>
<pre><code>(gdb) list
530
531     #[allow(unused_variables)]
532     #[doc(hidden)]
533     #[no_mangle]
534     pub unsafe extern &quot;C&quot; fn UserHardFault_(ef: &amp;ExceptionFrame) -&gt; ! {
535         loop {
536             // add some side effect to prevent this from turning into a UDF instruction
537             // see rust-lang/rust#28728 for details
538             atomic::compiler_fence(Ordering::SeqCst);
539         }
</code></pre>
<p><code>ef</code> is a snapshot of the program state right before the exception occurred. Let's inspect it:</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x48001800,
  r1: 0x48001800,
  r2: 0xb,
  r3: 0xc,
  r12: 0xd,
  lr: 0x800019f,
  pc: 0x80028d6,
  xpsr: 0x1000000
}
</code></pre>
<p>There are several fields here but the most important one is <code>pc</code>, the Program Counter register.
The address in this register points to the instruction that generated the exception. Let's
disassemble the program around the bad instruction.</p>
<pre><code>(gdb) disassemble /m ef.pc
Dump of assembler code for function core::ptr::read_volatile:
471     /checkout/src/libcore/ptr.rs: No such file or directory.
   0x080028ce &lt;+0&gt;:     sub     sp, #16
   0x080028d0 &lt;+2&gt;:     mov     r1, r0
   0x080028d2 &lt;+4&gt;:     str     r0, [sp, #8]

472     in /checkout/src/libcore/ptr.rs
   0x080028d4 &lt;+6&gt;:     ldr     r0, [sp, #8]
   0x080028d6 &lt;+8&gt;:     ldr     r0, [r0, #0]
   0x080028d8 &lt;+10&gt;:    str     r0, [sp, #12]
   0x080028da &lt;+12&gt;:    ldr     r0, [sp, #12]
   0x080028dc &lt;+14&gt;:    str     r1, [sp, #4]
   0x080028de &lt;+16&gt;:    str     r0, [sp, #0]
   0x080028e0 &lt;+18&gt;:    b.n     0x80028e2 &lt;core::ptr::read_volatile+20&gt;

473     in /checkout/src/libcore/ptr.rs
   0x080028e2 &lt;+20&gt;:    ldr     r0, [sp, #0]
   0x080028e4 &lt;+22&gt;:    add     sp, #16
   0x080028e6 &lt;+24&gt;:    bx      lr

End of assembler dump.
</code></pre>
<p>The exception was caused by the <code>ldr r0, [r0, #0]</code> instruction, a read instruction. The instruction
tried to read the memory at the address indicated by the <code>r0</code> register. By the way, <code>r0</code> is a CPU
(processor) register not a memory mapped register; it doesn't have an associated address like, say,
<code>GPIO_BSRR</code>.</p>
<p>Wouldn't it be nice if we could check what the value of the <code>r0</code> register was right at the instant
when the exception was raised? Well, we already did! The <code>r0</code> field in the <code>ef</code> value we printed
before is the value of <code>r0</code> register had when the exception was raised. Here it is again:</p>
<pre><code>(gdb) p/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x48001800,
  r1: 0x48001800,
  r2: 0xb,
  r3: 0xc,
  r12: 0xd,
  lr: 0x800019f,
  pc: 0x80028d6,
  xpsr: 0x1000000
}
</code></pre>
<p><code>r0</code> contains the value <code>0x4800_1800</code> which is the invalid address we called the <code>read_volatile</code>
function with.</p>
<a class="header" href="#spooky-action-at-a-distance" id="spooky-action-at-a-distance"><h1>Spooky action at a distance</h1></a>
<p><code>BSRR</code> is not the only register that can control the pins of Port E. The <code>ODR</code> register also lets
you change the value of the pins. Furthermore, <code>ODR</code> also lets you retrieve the current output
status of Port E.</p>
<p><code>ODR</code> is documented in:</p>
<blockquote>
<p>Section 11.4.6 GPIO port output data register - Page 239</p>
</blockquote>
<p>Let's try this program:</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let mut itm = aux7::init().0;

    unsafe {
        const GPIOE_BSRR: u32 = 0x4800_1018;
        const GPIOE_ODR: u32 = 0x4800_1014;

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // Turn on the NORTH LED (red)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // Turn on the EAST LED (green)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // Turn off the NORTH LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // Turn off the EAST LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}
</code></pre></pre>
<p>If you run this program, you'll see:</p>
<pre><code class="language-console">$ # itmdump's console
(..)
ODR = 0x0000
ODR = 0x0200
ODR = 0x0a00
ODR = 0x0800
</code></pre>
<p>Side effects! Although we are reading the same address multiple times without actually modifying it,
we still see its value change every time <code>BSRR</code> is written to.</p>
<a class="header" href="#type-safe-manipulation" id="type-safe-manipulation"><h1>Type safe manipulation</h1></a>
<p>The last register we were working with, <code>ODR</code>, had this in its documentation:</p>
<blockquote>
<p>Bits 16:31 Reserved, must be kept at reset value</p>
</blockquote>
<p>We are not supposed to write to those bits of the register or Bad Stuff May Happen.</p>
<p>There's also the fact the registers have different read/write permissions. Some of them are write
only, others can be read and wrote to and there must be others that are read only.</p>
<p>Finally, directly working with hexadecimal addresses is error prone. You already saw that trying to
access an invalid memory address causes an exception which disrupts the execution of our program.</p>
<p>Wouldn't it be nice if we had an API to manipulate registers in a &quot;safe&quot; manner? Ideally, the API
should encode these three points I've mentioned: No messing around with the actual addresses, should
respect read/write permissions and should prevent modification of the reserved parts of a register.</p>
<p>Well, we do! <code>aux7::init()</code> actually returns a value that provides a type safe API to manipulate the
registers of the  <code>GPIOE</code> peripheral.</p>
<p>As you may remember: a group of registers associated to a peripheral is called register block, and
it's located in a contiguous region of memory. In this type safe API each register block is modeled
as a <code>struct</code> where each of its fields represents a register. Each register field is a different
newtype over e.g. <code>u32</code> that exposes a combination of the following methods: <code>read</code>, <code>write</code> or
<code>modify</code> according to its read/write permissions. Finally, these methods don't take primitive values
like <code>u32</code>, instead they take yet another newtype that can be constructed using the builder pattern
and that prevent the modification of the reserved parts of the register.</p>
<p>The best way to get familiar with this API is to port our running example to it.</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let gpioe = aux7::init().1;

    // Turn on the North LED
    gpioe.bsrr.write(|w| w.bs9().set_bit());

    // Turn on the East LED
    gpioe.bsrr.write(|w| w.bs11().set_bit());

    // Turn off the North LED
    gpioe.bsrr.write(|w| w.br9().set_bit());

    // Turn off the East LED
    gpioe.bsrr.write(|w| w.br11().set_bit());

    loop {}
}
</code></pre></pre>
<p>First thing you notice: There are no magic addresses involved. Instead we use a more human friendly
way, for example <code>gpioe.bsrr</code>, to refer to the <code>BSRR</code> register in the <code>GPIOE</code> register block.</p>
<p>Then we have this <code>write</code> method that takes a closure. If the identity closure (<code>|w| w</code>) is used,
this method will set the register to its <em>default</em> (reset) value, the value it had right after the
microcontroller was powered on / reset. That value is <code>0x0</code> for the <code>BSRR</code> register. Since we want
to write a non-zero value to the register, we use builder methods like <code>bs9</code> and <code>br9</code> to set some
of the bits of the default value.</p>
<p>Let's run this program! There's some interesting stuff we can do <em>while</em> debugging the program.</p>
<p><code>gpioe</code> is a reference to the <code>GPIOE</code> register block. <code>print gpioe</code> will return the base address of
the register block.</p>
<pre><code>$ cargo run
Breakpoint 3, main () at src/07-registers/src/main.rs:9
9           let gpioe = aux7::init().1;

(gdb) next
12          gpioe.bsrr.write(|w| w.bs9().set_bit());

(gdb) print gpioe
$1 = (stm32f30x::gpioc::RegisterBlock *) 0x48001000
</code></pre>
<p>But if we instead <code>print *gpioe</code>, we'll get a <em>full view</em> of the register block: the value of each
of its registers will be printed.</p>
<pre><code>(gdb) print *gpioe
$2 = stm32f30x::gpioc::RegisterBlock {
  moder: stm32f30x::gpioc::MODER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x55550000
      }
    }
  },
  otyper: stm32f30x::gpioc::OTYPER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  ospeedr: stm32f30x::gpioc::OSPEEDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  pupdr: stm32f30x::gpioc::PUPDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  idr: stm32f30x::gpioc::IDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0xcc
      }
    }
  },
  odr: stm32f30x::gpioc::ODR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  bsrr: stm32f30x::gpioc::BSRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: stm32f30x::gpioc::LCKR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrl: stm32f30x::gpioc::AFRL {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrh: stm32f30x::gpioc::AFRH {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  brr: stm32f30x::gpioc::BRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<p>All these newtypes and closures sound like they'd generate large, bloated programs but, if you
actually compile the program in release mode with <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">LTO</a> enabled, you'll see that it produces exactly
the same instructions that the &quot;unsafe&quot; version that used <code>write_volatile</code> and hexadecimal addresses
did!</p>
<pre><code class="language-console">$ cargo objdump --bin registers --release -- -d -no-show-raw-insn -print-imm-hex
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
 8000188:       bl      #0x22
 800018c:       movw    r0, #0x1018
 8000190:       mov.w   r1, #0x200
 8000194:       movt    r0, #0x4800
 8000198:       str     r1, [r0]
 800019a:       mov.w   r1, #0x800
 800019e:       str     r1, [r0]
 80001a0:       mov.w   r1, #0x2000000
 80001a4:       str     r1, [r0]
 80001a6:       mov.w   r1, #0x8000000
 80001aa:       str     r1, [r0]
 80001ac:       b       #-0x4 &lt;main+0x24&gt;
</code></pre>
<p>The best part of all this is that I didn't have to write a single line of code to implement the
GPIOE API. All was automatically generated from a System View Description (SVD) file using the
<a href="https://crates.io/crates/svd2rust">svd2rust</a> tool. This SVD file is actually an XML file that microcontroller vendors provide and that
contains the register maps of their microcontrollers. The file contains the layout of register
blocks, the base addresses, the read/write permissions of each register, the layout of the
registers, whether a register has reserved bits and lots of other useful information.</p>
<a class="header" href="#leds-again" id="leds-again"><h1>LEDs, again</h1></a>
<p>In the last section, I gave you <em>initialized</em> (configured) peripherals (I initialized them in
<code>aux7::init</code>). That's why just writing to <code>BSRR</code> was enough to control the LEDs. But, peripherals
are not <em>initialized</em> right after the microcontroller boots.</p>
<p>In this section, you'll have more fun with registers. I won't do any initialization and you'll have
to initialize configure <code>GPIOE</code> pins as digital outputs pins so that you'll be able to drive LEDs
again.</p>
<p>This is the starter code.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux8::entry;

#[entry]
fn main() -&gt; ! {
    let (gpioe, rcc) = aux8::init();

    // TODO initialize GPIOE

    // Turn on all the LEDs in the compass
    gpioe.odr.write(|w| {
        w.odr8().set_bit();
        w.odr9().set_bit();
        w.odr10().set_bit();
        w.odr11().set_bit();
        w.odr12().set_bit();
        w.odr13().set_bit();
        w.odr14().set_bit();
        w.odr15().set_bit()
    });

    aux8::bkpt();

    loop {}
}

</code></pre></pre>
<p>If you run the starter code, you'll see that nothing happens this time. Furthermore, if you print
the <code>GPIOE</code> register block, you'll see that every register reads as zero even after the
<code>gpioe.odr.write</code> statement was executed!</p>
<pre><code>$ cargo run
Breakpoint 1, main () at src/08-leds-again/src/main.rs:9
9           let (gpioe, rcc) = aux8::init();

(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x08000f3c in __bkpt ()

(gdb) finish
Run till exit from #0  0x08000f3c in __bkpt ()
main () at src/08-leds-again/src/main.rs:25
25          aux8::bkpt();

(gdb) p/x *gpioe
$1 = stm32f30x::gpioc::RegisterBlock {
  moder: stm32f30x::gpioc::MODER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  otyper: stm32f30x::gpioc::OTYPER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  ospeedr: stm32f30x::gpioc::OSPEEDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  pupdr: stm32f30x::gpioc::PUPDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  idr: stm32f30x::gpioc::IDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  odr: stm32f30x::gpioc::ODR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  bsrr: stm32f30x::gpioc::BSRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: stm32f30x::gpioc::LCKR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrl: stm32f30x::gpioc::AFRL {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrh: stm32f30x::gpioc::AFRH {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  brr: stm32f30x::gpioc::BRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<a class="header" href="#power" id="power"><h1>Power</h1></a>
<p>Turns out that, to save power, most peripherals start in a powered off state -- that's their state
right after the microcontroller boots.</p>
<p>The Reset and Clock Control (<code>RCC</code>) peripheral can be used to power on or off every other
peripheral.</p>
<p>You can find the list of registers in the <code>RCC</code> register block in:</p>
<blockquote>
<p>Section 9.4.14 - RCC register map - Page 166 - Reference Manual</p>
</blockquote>
<p>The registers that control the power status of other peripherals are:</p>
<ul>
<li><code>AHBENR</code></li>
<li><code>APB1ENR</code></li>
<li><code>APB2ENR</code></li>
</ul>
<p>Each bit in these registers controls the power status of a single peripheral, including <code>GPIOE</code>.</p>
<p>Your task in this section is to power on the <code>GPIOE</code> peripheral. You'll have to:</p>
<ul>
<li>Figure out which of the three registers I mentioned before has the bit that controls the power
status.</li>
<li>Figure out what value that bit must be set to,<code>0</code> or <code>1</code>, to power on the <code>GPIOE</code> peripheral.</li>
<li>Finally, you'll have to change the starter code to <em>modify</em> the right register to turn on the
<code>GPIOE</code> peripheral.</li>
</ul>
<p>If you are successful, you'll see that the <code>gpioe.odr.write</code> statement will now be able to modify
the value of the <code>ODR</code> register.</p>
<p>Note that this won't be enough to actually turn on the LEDs.</p>
<a class="header" href="#configuration" id="configuration"><h1>Configuration</h1></a>
<p>After turning on the GPIOE peripheral. The peripheral still needs to be configured. In this case, we
want the pins to be configured as digital <em>outputs</em> so they can drive the LEDs; by default, most
pins are configured as digital <em>inputs</em>.</p>
<p>You can find the list of registers in the <code>GPIOE</code> register block in:</p>
<blockquote>
<p>Section 11.4.12 - GPIO registers - Page 243 - Reference Manual</p>
</blockquote>
<p>The register we'll have to deal with is: <code>MODER</code>.</p>
<p>Your task for this section is to further update the starter code to configure the <em>right</em> <code>GPIOE</code>
pins as digital outputs. You'll have to:</p>
<ul>
<li>Figure out <em>which</em> pins you need to configure as digital outputs. (hint: check Section 6.4 LEDs of
the <em>User Manual</em> (page 18)).</li>
<li>Read the documentation to understand what the bits in the <code>MODER</code> register do.</li>
<li>Modify the <code>MODER</code> register to configure the pins as digital outputs.</li>
</ul>
<p>If successful, you'll see the 8 LEDs turn on when you run the program.</p>
<a class="header" href="#the-solution" id="the-solution"><h1>The solution</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux8::entry;

#[entry]
fn main() -&gt; ! {
    let (gpioe, rcc) = aux8::init();

    // enable the GPIOE peripheral
    rcc.ahbenr.modify(|_, w| w.iopeen().set_bit());

    // configure the pins as outputs
    gpioe.moder.modify(|_, w| {
        w.moder8().output();
        w.moder9().output();
        w.moder10().output();
        w.moder11().output();
        w.moder12().output();
        w.moder13().output();
        w.moder14().output();
        w.moder15().output()
    });

    // Turn on all the LEDs in the compass
    gpioe.odr.write(|w| {
        w.odr8().set_bit();
        w.odr9().set_bit();
        w.odr10().set_bit();
        w.odr11().set_bit();
        w.odr12().set_bit();
        w.odr13().set_bit();
        w.odr14().set_bit();
        w.odr15().set_bit()
    });

    aux8::bkpt();

    loop {}
}
</code></pre></pre>
<a class="header" href="#clocks-and-timers" id="clocks-and-timers"><h1>Clocks and timers</h1></a>
<p>In this section, we'll re-implement the LED roulette application. I'm going to give you back the
<code>Led</code> abstraction but this time I'm going to take away the <code>Delay</code> abstraction <code>:-)</code>.</p>
<p>Here's the starter code. The <code>delay</code> function is unimplemented so if you run this program the LEDs
will blink so fast that they'll appear to always be on.</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use aux9::{entry, tim6};

#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    // TODO implement this
}

#[entry]
fn main() -&gt; ! {
    let (mut leds, rcc, tim6) = aux9::init();

    // TODO initialize TIM6

    let ms = 50;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay(tim6, ms);
            leds[curr].off();
            delay(tim6, ms);
        }
    }
}

</code></pre></pre>
<a class="header" href="#for-loop-delays" id="for-loop-delays"><h1><code>for</code> loop delays</h1></a>
<p>The first challenge is to implement the <code>delay</code> function without using any peripheral and the
obvious solution is to implement it as a <code>for</code> loop delay:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    for _ in 0..1_000 {}
}
#}</code></pre></pre>
<p>Of course, the above implementation is wrong because it always generates the same delay for any
value of <code>ms</code>.</p>
<p>In this section, you'll have to:</p>
<ul>
<li>Fix the <code>delay</code> function to generate delays proportional to its input <code>ms</code>.</li>
<li>Tweak the <code>delay</code> function to make the LED roulette spin at a rate of approximately 5 cycles in 4
seconds (800 milliseconds period).</li>
<li>The processor inside the microcontroller is clocked at 8 MHz and executes most instructions in one
&quot;tick&quot;, a cycle of its clock. How many (<code>for</code>) loops do  you <em>think</em> the <code>delay</code> function must do
to generate a delay of 1 second?</li>
<li>How many <code>for</code> loops does <code>delay(1000)</code> actually do?</li>
<li>What happens if compile your program in release mode and run it?</li>
</ul>
<a class="header" href="#nop" id="nop"><h1>NOP</h1></a>
<p>If in the previous section you compiled the program in release mode and actually looked at the
disassembly, you probably noticed that the <code>delay</code> function is optimized away and never gets called
from within <code>main</code>.</p>
<p>LLVM decided that the function wasn't doing anything worthwhile and just removed it.</p>
<p>There is a way to prevent LLVM from optimizing the <code>for</code> loop delay: add a <em>volatile</em> assembly
instruction. Any instruction will do but NOP (No OPeration) is a particular good choice in this case
because it has no side effect.</p>
<p>Your <code>for</code> loop delay would become:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline(never)]
fn delay(_tim6: &amp;tim6::RegisterBlock, ms: u16) {
    const K: u16 = 3; // this value needs to be tweaked
    for _ in 0..(K * ms) {
        aux9::nop()
    }
}
#}</code></pre></pre>
<p>And this time <code>delay</code> won't be compiled away by LLVM when you compile your program in release mode:</p>
<pre><code class="language-console">$ cargo objdump --bin clocks-and-timers --release -- -d -no-show-raw-insn
clocks-and-timers:      file format ELF32-arm-little

Disassembly of section .text:
clocks_and_timers::delay::h711ce9bd68a6328f:
 8000188:       push    {r4, r5, r7, lr}
 800018a:       movs    r4, #0
 800018c:       adds    r4, #1
 800018e:       uxth    r5, r4
 8000190:       bl      #4666
 8000194:       cmp     r5, #150
 8000196:       blo     #-14 &lt;clocks_and_timers::delay::h711ce9bd68a6328f+0x4&gt;
 8000198:       pop     {r4, r5, r7, pc}
</code></pre>
<p>Now, test this: Compile the program in debug mode and run it, then compile the program in release
mode and run it. What's the difference between them? What do you think is the main cause of the
difference? Can you think of a way to make them equivalent or at least more similar again?</p>
<a class="header" href="#one-shot-timer" id="one-shot-timer"><h1>One-shot timer</h1></a>
<p>I hope that, by now, I have convinced you that <code>for</code> loop delays are a poor way to implement delays.</p>
<p>Now, we'll implement delays using a <em>hardware timer</em>. The basic function of a (hardware) timer is
... to keep precise track of time. A timer is yet another peripheral that's available to the
microcontroller; thus it can be controlled using registers.</p>
<p>The microcontroller we are using has several (in fact, more than 10) timers of different kinds
(basic, general purpose, and advanced timers) available to it. Some timers have more <em>resolution</em>
(number of bits) than others and some can be used for more than just keeping track of time.</p>
<p>We'll be using one of the <em>basic</em> timers: <code>TIM6</code>. This is one of the simplest timers available in
our microcontroller. The documentation for basic timers is in the following section:</p>
<blockquote>
<p>Section 22 Timers - Page 670 - Reference Manual</p>
</blockquote>
<p>Its registers are documented in:</p>
<blockquote>
<p>Section 22.4.9 TIM6/TIM7 register map - Page 682 - Reference Manual</p>
</blockquote>
<p>The registers we'll be using in this section are:</p>
<ul>
<li><code>SR</code>, the status register.</li>
<li><code>EGR</code>, the event generation register.</li>
<li><code>CNT</code>, the counter register.</li>
<li><code>PSC</code>, the prescaler register.</li>
<li><code>ARR</code>, the autoreload register.</li>
</ul>
<p>We'll be using the timer as a <em>one-shot</em> timer. It will sort of work like an alarm clock. We'll set
the timer to go off after some amount of time and then we'll wait until the timer goes off. The
documentation refers to this mode of operation as <em>one pulse mode</em>.</p>
<p>Here's a description of how a basic timer works when configured in one pulse mode:</p>
<ul>
<li>The counter is enabled by the user (<code>CR1.CEN = 1</code>).</li>
<li>The <code>CNT</code> register resets its value to zero and, on each tick, its value gets incremented by one.</li>
<li>Once the <code>CNT</code> register has reached the value of the <code>ARR</code> register, the counter will be disabled
by hardware (<code>CR1.CEN = 0</code>) and an <em>update event</em> will be raised (<code>SR.UIF = 1</code>).</li>
</ul>
<p><code>TIM6</code> is driven by the APB1 clock, whose frequency doesn't have to necessarily match the processor
frequency. That is, the APB1 clock could be running faster or slower. The default, however, is that
both APB1 and the processor are clocked at 8 MHz.</p>
<p>The tick mentioned in the functional description of the one pulse mode is <em>not</em> the same as one
tick of the APB1 clock. The <code>CNT</code> register increases at a frequency of <code>apb1 / (psc + 1)</code>
times per second, where <code>apb1</code> is the frequency of the APB1 clock and <code>psc</code> is the value of the
prescaler register, <code>PSC</code>.</p>
<a class="header" href="#initialization" id="initialization"><h1>Initialization</h1></a>
<p>As with every other peripheral, we'll have to initialize this timer before we can use it. And just
as in the previous section, initialization is going to involve two steps: powering up the timer and
then configuring it.</p>
<p>Powering up the timer is easy: We just have to set <code>TIM6EN</code> bit to 1. This bit is in the <code>APB1ENR</code>
register of the <code>RCC</code> register block.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Power on the TIM6 timer
    rcc.apb1enr.modify(|_, w| w.tim6en().set_bit());
#}</code></pre></pre>
<p>The configuration part is slightly more elaborate.</p>
<p>First, we'll have to configure the timer to operate in one pulse mode.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // OPM Select one pulse mode
    // CEN Keep the counter disabled for now
    tim6.cr1.write(|w| w.opm().set_bit().cen().clear_bit());
#}</code></pre></pre>
<p>Then, we'll like to have the <code>CNT</code> counter operate at a frequency of 1 KHz because our <code>delay</code>
function takes a number of milliseconds as arguments and 1 KHz produces a 1 millisecond period. For
that we'll have to configure the prescaler.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Configure the prescaler to have the counter operate at 1 KHz
    tim6.psc.write(|w| w.psc().bits(psc));
#}</code></pre></pre>
<p>I'm going to let you figure out the value of the prescaler, <code>psc</code>. Remember that the frequency of
the counter is <code>apb1 / (psc + 1)</code> and that <code>apb1</code> is 8 MHz.</p>
<a class="header" href="#busy-waiting" id="busy-waiting"><h1>Busy waiting</h1></a>
<p>The timer should now be properly initialized. All that's left is to implement the <code>delay</code> function
using the timer.</p>
<p>First thing we have to do is set the autoreload register (<code>ARR</code>) to make the timer go off in <code>ms</code>
milliseconds. Because the counter operates at 1 KHz, the autoreload value will be the same as <code>ms</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Set the timer to go off in `ms` ticks
    // 1 tick = 1 ms
    tim6.arr.write(|w| w.arr().bits(ms));
#}</code></pre></pre>
<p>Next, we need to enable the counter. It will immediately start counting.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // CEN: Enable the counter
    tim6.cr1.modify(|_, w| w.cen().set_bit());
#}</code></pre></pre>
<p>Now we need to wait until the counter reaches the value of the autoreload register, <code>ms</code>, then we'll
know that <code>ms</code> milliseconds have passed. That condition is known as an <em>update event</em> and its
indicated by the <code>UIF</code> bit of the status register (<code>SR</code>).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Wait until the alarm goes off (until the update event occurs)
    while !tim6.sr.read().uif().bit_is_set() {}
#}</code></pre></pre>
<p>This pattern of just waiting until some condition is met, in this case that <code>UIF</code> becomes <code>1</code>, is
known as <em>busy waiting</em> and you'll see it a few more times in this text <code>:-)</code>.</p>
<p>Finally, we must clear (set to <code>0</code>) this <code>UIF</code> bit. If we don't, next time we enter the <code>delay</code>
function we'll think the update event has already happened and skip over the busy waiting part.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Clear the update event flag
    tim6.sr.modify(|_, w| w.uif().clear_bit());
#}</code></pre></pre>
<p>Now, put this all together and check if it works as expected.</p>
<a class="header" href="#putting-it-all-together" id="putting-it-all-together"><h1>Putting it all together</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use aux9::{entry, tim6};

#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    // Set the timer to go off in `ms` ticks
    // 1 tick = 1 ms
    tim6.arr.write(|w| w.arr().bits(ms));

    // CEN: Enable the counter
    tim6.cr1.modify(|_, w| w.cen().set_bit());

    // Wait until the alarm goes off (until the update event occurs)
    while !tim6.sr.read().uif().bit_is_set() {}

    // Clear the update event flag
    tim6.sr.modify(|_, w| w.uif().clear_bit());
}

#[entry]
fn main() -&gt; ! {
    let (mut leds, rcc, tim6) = aux9::init();

    // Power on the TIM6 timer
    rcc.apb1enr.modify(|_, w| w.tim6en().set_bit());

    // OPM Select one pulse mode
    // CEN Keep the counter disabled for now
    tim6.cr1.write(|w| w.opm().set_bit().cen().clear_bit());

    // Configure the prescaler to have the counter operate at 1 KHz
    // APB1_CLOCK = 8 MHz
    // PSC = 7999
    // 8 MHz / (7999 + 1) = 1 KHz
    // The counter (CNT) will increase on every millisecond
    tim6.psc.write(|w| w.psc().bits(7_999));

    let ms = 50;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay(tim6, ms);
            leds[curr].off();
            delay(tim6, ms);
        }
    }
}
</code></pre></pre>
<a class="header" href="#serial-communication" id="serial-communication"><h1>Serial communication</h1></a>
<p><a href="https://en.wikipedia.org/wiki/File:Serial_port.jpg"></p>
<p align="center">
<img height="240" title="Standard serial port connector DE-9" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Serial_port.jpg/800px-Serial_port.jpg">
</p>
</a>
<p align="center">
<em>This is what we'll be using. I hope your laptop has one!</em>
</p>
<p>Nah, don't worry. This connector, the DE-9, went out of fashion on PCs quite some time ago; it got
replaced by the Universal Serial Bus (USB). We won't be dealing with the DE-9 connector itself but
with the communication protocol that this cable is/was usually used for.</p>
<p>So what's this <em>serial communication</em>? It's an <em>asynchronous</em> communication protocol where two
devices exchange data <em>serially</em>, as in one bit at a time, using two data lines (plus a common
ground). The protocol is asynchronous in the sense that neither of the shared lines carries a clock
signal. Instead both parties must agree on how fast data will be sent along the wire <em>before</em> the
communication occurs. This protocol allows <em>duplex</em> communication as data can be sent from A to B
and from B to A simultaneously.</p>
<p>We'll be using this protocol to exchange data between the microcontroller and your laptop. In
contrast to the ITM protocol we have used before, with the serial communication protocol you can
send data from your laptop to the microcontroller.</p>
<p>The next practical question you probably want to ask is: How fast can we send data through this
protocol?</p>
<p>This protocol works with frames. Each frame has one <em>start</em> bit, 5 to 9 bits of payload (data) and 1
to 2 <em>stop bits</em>. The speed of the protocol is known as <em>baud rate</em> and it's quoted in bits per
second (bps). Common baud rates are: 9600, 19200, 38400, 57600 and 115200 bps.</p>
<p>To actually answer the question: With a common configuration of 1 start bit, 8 bits of data, 1
stop bit and a baud rate of 115200 bps one can, in theory, send 11,520 frames per second. Since each
one frame carries a byte of data that results in a data rate of 11.52 KB/s. In practice, the data
rate will probably be lower because of processing times on the slower side of the communication (the
microcontroller).</p>
<p>Today's laptops/PCs don't support the serial communication protocol. So you can't directly connect
your laptop to the microcontroller. But that's where the serial module comes in. This module will
sit between the two and expose a serial interface to the microcontroller and an USB interface to
your laptop. The microcontroller will see your laptop as another serial device and your laptop
will see the microcontroller as a virtual serial device.</p>
<p>Now, let's get familiar with the serial module and the serial communication tools that your OS
offers. Pick a route:</p>
<ul>
<li><a href="nix-tooling.html">*nix</a></li>
<li><a href="windows-tooling.html">Windows</a></li>
</ul>
<a class="header" href="#nix-tooling" id="nix-tooling"><h1>*nix tooling</h1></a>
<p>Connect the serial module to your laptop and let's find out what name the OS assigned to it.</p>
<blockquote>
<p><strong>NOTE</strong> On macs, the USB device will named like this: <code>/dev/cu.usbserial-*</code>. You won't
find it using <code>dmesg</code>, instead use <code>ls -l /dev | grep cu.usb</code> and adjust the following
commands accordingly!</p>
</blockquote>
<pre><code class="language-console">$ dmesg | grep -i tty
(..)
[  +0.000155] usb 3-2: FTDI USB Serial Device converter now attached to ttyUSB0
</code></pre>
<p>But what's this <code>ttyUSB0</code> thing? It's a file of course! Everything is a file in *nix:</p>
<pre><code class="language-console">$ ls -l /dev/ttyUSB0
crw-rw-rw- 1 root uucp 188, 0 Oct 27 00:00 /dev/ttyUSB0
</code></pre>
<blockquote>
<p><strong>NOTE</strong> if the permissions above is <code>crw-rw----</code>, the udev rules have not been set correctly
see <a href="https://docs.rust-embedded.org/03-setup/linux.html#udev-rules">udev rules</a></p>
</blockquote>
<p>You can send out data by simply writing to this file:</p>
<pre><code class="language-console">$ echo 'Hello, world!' &gt; /dev/ttyUSB0
</code></pre>
<p>You should see the TX (red) LED on the serial module blink, just once and very fast!</p>
<a class="header" href="#minicom" id="minicom"><h2>minicom</h2></a>
<p>Dealing with serial devices using <code>echo</code> is far from ergonomic. So, we'll use the program <code>minicom</code>
to interact with the serial device using the keyboard.</p>
<p>We must configure <code>minicom</code> before we use it. There are quite a few ways to do that but we'll use a
<code>.minirc.dfl</code> file in the home directory. Create a file in <code>~/.minirc.dfl</code> with the following
contents:</p>
<pre><code class="language-console">$ cat ~/.minirc.dfl
pu baudrate 115200
pu bits 8
pu parity N
pu stopbits 1
pu rtscts No
pu xonxoff No
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Make sure this file ends in a newline! Otherwise, <code>minicom</code> will fail to read it.</p>
</blockquote>
<p>That file should be straightforward to read (except for the last two lines), but nonetheless let's
go over it line by line:</p>
<ul>
<li><code>pu baudrate 115200</code>. Sets baud rate to 115200 bps.</li>
<li><code>pu bits 8</code>. 8 bits per frame.</li>
<li><code>pu parity N</code>. No parity check.</li>
<li><code>pu stopbits 1</code>. 1 stop bit.</li>
<li><code>pu rtscts No</code>. No hardware control flow.</li>
<li><code>pu xonxoff No</code>. No software control flow.</li>
</ul>
<p>Once that's in place. We can launch <code>minicom</code></p>
<pre><code class="language-console">$ minicom -D /dev/ttyUSB0 -b 115200
</code></pre>
<p>This tells <code>minicom</code> to open the serial device at <code>/dev/ttyUSB0</code> and set its baud rate to 115200.
A text-based user interface (TUI) will pop out.</p>
<p align="center">
<img height="480" title="minicom" src="https://docs.rust-embedded.org/assets/minicom.png">
</p>
<p>You can now send data using the keyboard! Go ahead and type something. Note that the TUI <em>won't</em>
echo back what you type but you'll see TX (red) LED on the serial module blink with each keystroke.</p>
<a class="header" href="#minicom-commands" id="minicom-commands"><h2><code>minicom</code> commands</h2></a>
<p><code>minicom</code> exposes commands via keyboard shortcuts. On Linux, the shortcuts start with <code>Ctrl+A</code>. On
mac, the shortcuts start with the <code>Meta</code> key. Some useful commands below:</p>
<ul>
<li><code>Ctrl+A</code> + <code>Z</code>. Minicom Command Summary</li>
<li><code>Ctrl+A</code> + <code>C</code>. Clear the screen</li>
<li><code>Ctrl+A</code> + <code>X</code>. Exit and reset</li>
<li><code>Ctrl+A</code> + <code>Q</code>. Quit with no reset</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> mac users: In the above commands, replace <code>Ctrl+A</code> with <code>Meta</code>.</p>
</blockquote>
<a class="header" href="#windows-tooling" id="windows-tooling"><h1>Windows tooling</h1></a>
<p>Before plugging the Serial module, run the following command on the terminal:</p>
<pre><code class="language-console">$ mode
</code></pre>
<p>It will print a list of devices that are connected to your laptop. The ones that start with <code>COM</code> in
their names are serial devices. This is the kind of device we'll be working with. Take note of all
the <code>COM</code> <em>ports</em> <code>mode</code> outputs <em>before</em> plugging the serial module.</p>
<p>Now, plug the Serial module and run the <code>mode</code> command again. You should see a new <code>COM</code> port appear
on the list. That's the COM port assigned to the serial module.</p>
<p>Now launch <code>putty</code>. A GUI will pop out.</p>
<p align="center">
<img title="PuTTY settings" src="https://docs.rust-embedded.org/assets/putty-settings.png">
</p>
<p>On the starter screen, which should have the &quot;Session&quot; category open, pick &quot;Serial&quot; as the
&quot;Connection type&quot;. On the &quot;Serial line&quot; field enter the <code>COM</code> device you got on the previous step,
for example <code>COM3</code>.</p>
<p>Next, pick the &quot;Connection/Serial&quot; category from the menu on the left. On this new view, make sure
that the serial port is configured as follows:</p>
<ul>
<li>&quot;Speed (baud)&quot;: 115200</li>
<li>&quot;Data bits&quot;: 8</li>
<li>&quot;Stop bits&quot;: 1</li>
<li>&quot;Parity&quot;: None</li>
<li>&quot;Flow control&quot;: None</li>
</ul>
<p>Finally, click the Open button. A console will show up now:</p>
<p align="center">
<img title="PuTTY console" src="https://docs.rust-embedded.org/assets/putty-console.png">
</p>
<p>If you type on this console, the TX (red) LED on the Serial module should blink. Each key stroke
should make the LED blink once. Note that the console won't echo back what you type so the screen
will remain blank.</p>
<a class="header" href="#loopbacks" id="loopbacks"><h1>Loopbacks</h1></a>
<p>We've tested sending data. It's time to test receiving it. Except that there's no other device that
can send us some data ... or is there?</p>
<p>Enter: loopbacks</p>
<p align="center">
<img title="Serial module loopback" src="https://docs.rust-embedded.org/assets/serial-loopback.png">
</p>
<p>You can send data to yourself! Not very useful in production but very useful for debugging.</p>
<p>Connect the <code>TXO</code> and the <code>RXI</code> pins of the serial module together using a male to male jumper wire
as shown above.</p>
<p>Now enter some text into minicom/PuTTY and observe. What happens?</p>
<p>You should see three things:</p>
<ul>
<li>As before, the TX (red) LED blinks on each key press.</li>
<li>But now the RX (green) LED blinks on each key press as well! This indicates that the serial module
is receiving some data; the one it just sent.</li>
<li>Finally, on the minicom/PuTTY console, you should see that what you type echoes back to the
console.</li>
</ul>
<p>Now that you are familiar with sending and receiving data over serial port using minicom/PuTTY,
let's make your microcontroller and your laptop talk!</p>
<a class="header" href="#usart" id="usart"><h1>USART</h1></a>
<p>The microcontroller has a peripheral called USART, which stands for Universal
Synchronous/Asynchronous Receiver/Transmitter. This peripheral can be configured to work with
several communication protocols like the serial communication protocol.</p>
<p>Throughout this chapter, we'll use serial communication to exchange information between the
microcontroller and your laptop. But before we do that we have to wire up everything.</p>
<p>I mentioned before that this protocol involves two data lines: TX and RX. TX stands for transmitter
and RX stands for receiver. Transmitter and receiver are relative terms though; which line is the
transmitter and which line is the receiver depends from which side of the communication you are
looking at the lines.</p>
<p>We'll be using the pin <code>PA9</code> as the microcontroller's TX line and <code>PA10</code> as its RX line. In other
words, the pin <code>PA9</code> outputs data onto its wire whereas the pin <code>PA10</code> listens for data on its
wire.</p>
<p>We could have used a different pair of pins as the TX and RX pins. There's a table in page 44 of the
<a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">Data Sheet</a> that list all the other possible pins we could have used.</p>
<p>The serial module also has TX and RX pins. We'll have to <em>cross</em> these pins: that is connect the
microcontroller's TX pin to the serial module's RX pin and the micro's RX pin to the serial module's
TX pin. The wiring diagram below shows all the necessary connections.</p>
<p align="center">
<img height=640 title="F3 <-> Serial connection" src="../assets/f3-serial.png">
</p>
<p>These are the recommended steps to connect the microcontroller and the serial module:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code></li>
<li>Disconnect the USB cables from the F3 and the serial module.</li>
<li>Connect one of F3 GND pins to the GND pin of the serial module using a female to male (F/M) wire.
Preferably, a black one.</li>
<li>Connect the PA9 pin on the back of the F3 to the RXI pin of the serial module using a F/M wire.</li>
<li>Connect the PA10 pin on the back of the F3 to the TXO pin of the serial module using a F/M wire.</li>
<li>Now connect the USB cable to the F3.</li>
<li>Finally connect the USB cable to the Serial module.</li>
<li>Re-launch OpenOCD and <code>itmdump</code></li>
</ul>
<p>Everything's wired up! Let's proceed to send data back and forth.</p>
<a class="header" href="#send-a-single-byte" id="send-a-single-byte"><h1>Send a single byte</h1></a>
<p>Our first task will be to send a single byte from the microcontroller to the laptop over the serial
connection.</p>
<p>This time, I'm going to provide you with an already initialized USART peripheral. You'll only have
to work with the registers that are in charge of sending and receiving data.</p>
<p>Go into the <code>11-usart</code> directory and let's run the starter code therein. Make sure that you have
minicom/PuTTY open.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // Send a single character
    usart1.tdr.write(|w| w.tdr().bits(u16::from(b'X')));

    loop {}
}

</code></pre></pre>
<p>This program writes to the <code>TDR</code> register. This causes the <code>USART</code> peripheral to send one byte of
information through the serial interface.</p>
<p>On the receiving end, your laptop, you should see show the character <code>X</code> appear on minicom/PuTTY's
terminal.</p>
<a class="header" href="#send-a-string" id="send-a-string"><h1>Send a string</h1></a>
<p>The next task will be to send a whole string from the micro to your laptop.</p>
<p>I want you to send the string <code>&quot;The quick brown fox jumps over the lazy dog.&quot;</code> from the micro to
your laptop.</p>
<p>It's your turn to write the program.</p>
<p>Execute your program inside the debugger, statement by statement. What do you see?</p>
<p>Then execute the program again but in <em>one go</em> using the <code>continue</code> command. What happens this time?</p>
<p>Finally, build the program in <em>release</em> mode and, again, run it one go. What happens this time?</p>
<a class="header" href="#overruns" id="overruns"><h1>Overruns</h1></a>
<p>If you wrote your program like this:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // Send a string
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }

    loop {}
}
</code></pre></pre>
<p>You probably received something like this on your laptop when you executed the program compiled in
debug mode.</p>
<pre><code class="language-console">$ # minicom's terminal
(..)
The uic brwn oxjums oer helaz do.
</code></pre>
<p>And if you compiled in release mode, you probably only got something like this:</p>
<pre><code class="language-console">$ # minicom's terminal
(..)
T
</code></pre>
<p>What went wrong?</p>
<p>You see, sending bytes over the wire takes a relatively large amount of time. I already did the math
so let me quote myself:</p>
<blockquote>
<p>With a common configuration of 1 start bit, 8 bits of data, 1 stop bit and a baud rate of 115200
bps one can, in theory, send 11,520 frames per second. Since each one frame carries a byte of data
that results in a data rate of 11.52 KB/s</p>
</blockquote>
<p>Our pangram has a length of 45 bytes. That means it's going to take, at least, 3,900 microseconds
(<code>45 bytes / (11,520 bytes/s) = 3,906 us</code>) to send the string. The processor is working at 8 MHz,
where executing an instruction takes 125 nanoseconds, so it's likely going to be done with the <code>for</code>
loop in less than 3,900 microseconds.</p>
<p>We can actually time how long it takes to execute the <code>for</code> loop. <code>aux11::init()</code> returns a
<code>MonoTimer</code> (monotonic timer) value that exposes an <code>Instant</code> API that's similar to the one in
<code>std::time</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, mut itm) = aux11::init();

    let instant = mono_timer.now();
    // Send a string
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // in ticks

    iprintln!(
        &amp;mut itm.stim[0],
        &quot;`for` loop took {} ticks ({} us)&quot;,
        elapsed,
        elapsed as f32 / mono_timer.frequency().0 as f32 * 1e6
    );

    loop {}
}
</code></pre></pre>
<p>In debug mode, I get:</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
`for` loop took 22415 ticks (2801.875 us)
</code></pre>
<p>This is less than 3,900 microseconds but it's not that far off and that's why only a few bytes of
information are lost.</p>
<p>In conclusion, the processor is trying to send bytes at a faster rate than what the hardware can
actually handle and this results in data loss. This condition is known as buffer <em>overrun</em>.</p>
<p>How do we avoid this? The status register (<code>ISR</code>) has a flag, <code>TXE</code>, that indicates if it's &quot;safe&quot;
to write to the <code>TDR</code> register without incurring in data loss.</p>
<p>Let's use that to slowdown the processor.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, mut itm) = aux11::init();

    let instant = mono_timer.now();
    // Send a string
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        // wait until it's safe to write to TDR
        while usart1.isr.read().txe().bit_is_clear() {} // &lt;- NEW!

        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // in ticks

    iprintln!(
        &amp;mut itm.stim[0],
        &quot;`for` loop took {} ticks ({} us)&quot;,
        elapsed,
        elapsed as f32 / mono_timer.frequency().0 as f32 * 1e6
    );

    loop {}
}
</code></pre></pre>
<p>This time, running the program in debug or release mode should result in a complete string on the
receiving side.</p>
<pre><code class="language-console">$ # minicom/PuTTY's console
(..)
The quick brown fox jumps over the lazy dog.
</code></pre>
<p>The timing of the <code>for</code> loop should be closer to the theoretical 3,900 microseconds as well. The
timing below is for the debug version.</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
`for` loop took 30499 ticks (3812.375 us)
</code></pre>
<a class="header" href="#uprintln" id="uprintln"><h1><code>uprintln!</code></h1></a>
<p>For the next exercise, we'll implement the <code>uprint!</code> family of macros. Your goal is to make this
line of code work:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    uprintln!(serial, &quot;The answer is {}&quot;, 40 + 2);
#}</code></pre></pre>
<p>Which must send the string <code>&quot;The answer is 42&quot;</code> through the serial interface.</p>
<p>How do we go about that? It's informative to look into the <code>std</code> implementation of <code>println!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/libstd/macros.rs
macro_rules! print {
    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));
}
#}</code></pre></pre>
<p>Looks simple so far. We need the built-in <code>format_args!</code> macro (it's implemented in the compiler so we
can't see what it actually does). We'll have to use that macro in the exact same way. What does this
<code>_print</code> function do?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/libstd/io/stdio.rs
pub fn _print(args: fmt::Arguments) {
    let result = match LOCAL_STDOUT.state() {
        LocalKeyState::Uninitialized |
        LocalKeyState::Destroyed =&gt; stdout().write_fmt(args),
        LocalKeyState::Valid =&gt; {
            LOCAL_STDOUT.with(|s| {
                if s.borrow_state() == BorrowState::Unused {
                    if let Some(w) = s.borrow_mut().as_mut() {
                        return w.write_fmt(args);
                    }
                }
                stdout().write_fmt(args)
            })
        }
    };
    if let Err(e) = result {
        panic!(&quot;failed printing to stdout: {}&quot;, e);
    }
}
#}</code></pre></pre>
<p>That <em>looks</em> complicated but the only part we are interested in is: <code>w.write_fmt(args)</code> and
<code>stdout().write_fmt(args)</code>. What <code>print!</code> ultimately does is call the <code>fmt::Write::write_fmt</code> method
with the output of <code>format_args!</code> as its argument.</p>
<p>Luckily we don't have to implement the <code>fmt::Write::write_fmt</code> method either because it's a default
method. We only have to implement the <code>fmt::Write::write_str</code> method.</p>
<p>Let's do that.</p>
<p>This is what the macro side of the equation looks like. What's left to be done by you is provide the
implementation of the <code>write_str</code> method.</p>
<p>Above we saw that <code>Write</code> is in <code>std::fmt</code>. We don't have access to <code>std</code> but <code>Write</code> is also
available in <code>core::fmt</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use core::fmt::{self, Write};

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln, usart1};

macro_rules! uprint {
    ($serial:expr, $($arg:tt)*) =&gt; {
        $serial.write_fmt(format_args!($($arg)*)).ok()
    };
}

macro_rules! uprintln {
    ($serial:expr, $fmt:expr) =&gt; {
        uprint!($serial, concat!($fmt, &quot;\n&quot;))
    };
    ($serial:expr, $fmt:expr, $($arg:tt)*) =&gt; {
        uprint!($serial, concat!($fmt, &quot;\n&quot;), $($arg)*)
    };
}

struct SerialPort {
    usart1: &amp;'static mut usart1::RegisterBlock,
}

impl fmt::Write for SerialPort {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        // TODO implement this
        // hint: this will look very similar to the previous program
        Ok(())
    }
}

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    let mut serial = SerialPort { usart1 };

    uprintln!(serial, &quot;The answer is {}&quot;, 40 + 2);

    loop {}
}
</code></pre></pre>
<a class="header" href="#receive-a-single-byte" id="receive-a-single-byte"><h1>Receive a single byte</h1></a>
<p>So far we have sending data from the micro to your laptop. It's time to try the opposite: receiving
data from your laptop.</p>
<p>There's a <code>RDR</code> register that will be filled with the data that comes from the RX line. If we read
that register, we'll retrieve the data that the other side of the channel sent. The question is: How
do we know that we have received (new) data? The status register, <code>ISR</code>, has a bit for that purpose:
<code>RXNE</code>. We can just busy wait on that flag.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    loop {
        // Wait until there's data available
        while usart1.isr.read().rxne().bit_is_clear() {}

        // Retrieve the data
        let _byte = usart1.rdr.read().rdr().bits() as u8;

        aux11::bkpt();
    }
}
</code></pre></pre>
<p>Let's try this program! Let it run free using <code>continue</code> and then type a single character in
minicom/PuTTY's console. What happens? What are the contents of the <code>_byte</code> variable?</p>
<pre><code>(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x8003d48 in __bkpt ()

(gdb) finish
Run till exit from #0  0x8003d48 in __bkpt ()
usart::main () at src/11-usart/src/main.rs:19
19              aux11::bkpt();

(gdb) p/c _byte
$1 = 97 'a'
</code></pre>
<a class="header" href="#echo-server" id="echo-server"><h1>Echo server</h1></a>
<p>Let's merge transmission and reception into a single program and write an echo server. An echo
server sends back to the client the same text it sent. For this application, the microcontroller
will be the server and you and your laptop will be the client.</p>
<p>This should be straightforward to implement. (hint: do it byte by byte)</p>
<a class="header" href="#reverse-a-string" id="reverse-a-string"><h1>Reverse a string</h1></a>
<p>Alright, next let's make the server more interesting by having it respond to the client with the
reverse of the text that they sent. The server will respond to the client every time they press the
ENTER key. Each server response will be in a new line.</p>
<p>This time you'll need a buffer; you can use <a href="https://docs.rs/heapless/0.2.1/heapless/struct.Vec.html"><code>heapless::Vec</code></a>. Here's the starter code:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};
use heapless::{consts, Vec};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, consts::U32&gt; = Vec::new();

    loop {
        buffer.clear();

        // TODO Receive a user request. Each user request ends with ENTER
        // NOTE `buffer.push` returns a `Result`. Handle the error by responding
        // with an error message.

        // TODO Send back the reversed string
    }
}
</code></pre></pre>
<a class="header" href="#my-solution-1" id="my-solution-1"><h1>My solution</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};
use heapless::{consts, Vec};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, consts::U32&gt; = Vec::new();

    loop {
        buffer.clear();

        loop {
            while usart1.isr.read().rxne().bit_is_clear() {}
            let byte = usart1.rdr.read().rdr().bits() as u8;

            if buffer.push(byte).is_err() {
                // buffer full
                for byte in b&quot;error: buffer full\n\r&quot; {
                    while usart1.isr.read().txe().bit_is_clear() {}
                    usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
                }

                break;
            }

            // Carriage return
            if byte == 13 {
                // Respond
                for byte in buffer.iter().rev().chain(&amp;[b'\n', b'\r']) {
                    while usart1.isr.read().txe().bit_is_clear() {}
                    usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
                }

                break;
            }
        }
    }
}
</code></pre></pre>
<a class="header" href="#bluetooth-setup" id="bluetooth-setup"><h1>Bluetooth setup</h1></a>
<p>It's time to get rid of some wires. Serial communication can not only be emulated on top of the USB
protocol; it can also be emulated on top of the Bluetooth protocol. This serial over Bluetooth
protocol is known as RFCOMM.</p>
<p>Before we use the Bluetooth module with the microcontroller, let's first interact with it using
minicom/PuTTY.</p>
<p>The first thing we'll need to do is: turn on the Bluetooth module. We'll have to share some of the
F3 power to it using the following connection:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (power only)" src="../assets/f3-bluetooth-power-only.png">
</p>
<p>The recommend steps to wire this up are:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code></li>
<li>Disconnect the USB cables from the F3 and the serial module.</li>
<li>Connect F3's GND pin to the Bluetooth's GND pin using a female to female (F/F) wire. Preferably, a
black one.</li>
<li>Connect F3's 5V pin to the Bluetooth's VCC pin using a F/F wire. Preferably, a red one.</li>
<li>Then, connect the USB cable back to the F3.</li>
<li>Re-launch OpenOCD and <code>itmdump</code></li>
</ul>
<p>Two LEDs, a blue one and a red one, on the Bluetooth module should start blinking right after you
power on the F3 board.</p>
<p>Next thing to do is pair your laptop and the Bluetooth module. AFAIK, Windows and mac users can
simply use their OS default Bluetooth manager to do the pairing. The Bluetooth module default pin
is 1234.</p>
<p>Linux users will have to follow (some of) <a href="linux.html">these instructions</a>.</p>
<a class="header" href="#linux-1" id="linux-1"><h1>Linux</h1></a>
<p>If you have a graphical Bluetooth manager, you can use that to pair your laptop to the Bluetooth
module and skip most of these steps. You'll probably still have to <a href="#rfcomm-device">this step</a> though.</p>
<a class="header" href="#power-up" id="power-up"><h2>Power up</h2></a>
<p>First, your laptop's Bluetooth transceiver may be OFF. Check its status with <code>hciconfig</code> and turn it
ON if necessary:</p>
<pre><code class="language-console">$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        DOWN  &lt;--
        RX bytes:580 acl:0 sco:0 events:31 errors:0
        TX bytes:368 acl:0 sco:0 commands:30 errors:0

$ sudo hciconfig hci0 up

$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        UP RUNNING  &lt;--
        RX bytes:1190 acl:0 sco:0 events:67 errors:0
        TX bytes:1072 acl:0 sco:0 commands:66 errors:0
</code></pre>
<p>Then you need to launch the BlueZ (Bluetooth) daemon:</p>
<ul>
<li>On systemd based Linux distributions, use:</li>
</ul>
<pre><code class="language-console">$ sudo systemctl start bluetooth
</code></pre>
<ul>
<li>On Ubuntu (or upstart based Linux distributions), use:</li>
</ul>
<pre><code class="language-console">$ sudo /etc/init.d/bluetooth start
</code></pre>
<p>You may also need to unblock your Bluetooth, depending on what <code>rfkill list</code> says:</p>
<pre><code class="language-console">$ rkfill list
9: hci0: Bluetooth
        Soft blocked: yes # &lt;--
        Hard blocked: no

$ sudo rfkill unblock bluetooth

$ rkfill list
9: hci0: Bluetooth
        Soft blocked: no  # &lt;--
        Hard blocked: no

</code></pre>
<a class="header" href="#scan" id="scan"><h2>Scan</h2></a>
<pre><code class="language-console">$ hcitool scan
Scanning ...
        20:16:05:XX:XX:XX       Ferris
$ #                             ^^^^^^
</code></pre>
<a class="header" href="#pair" id="pair"><h2>Pair</h2></a>
<pre><code class="language-console">$ bluetoothctl
[bluetooth]# scan on
[bluetooth]# agent on
[bluetooth]# pair 20:16:05:XX:XX:XX
Attempting to pair with 20:16:05:XX:XX:XX
[CHG] Device 20:16:05:XX:XX:XX Connected: yes
Request PIN code
[agent] Enter PIN code: 1234
</code></pre>
<a class="header" href="#rfcomm-device" id="rfcomm-device"><h2>rfcomm device</h2></a>
<p>We'll create a device file for our Bluetooth module in <code>/dev</code>. Then we'll be able to use it just
like we used <code>/dev/ttyUSB0</code>.</p>
<pre><code class="language-console">$ sudo rfcomm bind 0 20:16:05:XX:XX:XX
</code></pre>
<p>Because we used <code>0</code> as an argument to <code>bind</code>, <code>/dev/rfcomm0</code> will be the device file assigned to our
Bluetooth module.</p>
<p>You can release (destroy) the device file at any time with the following command:</p>
<pre><code class="language-console">$ # Don't actually run this command right now!
$ sudo rfcomm release 0
</code></pre>
<a class="header" href="#loopback-again" id="loopback-again"><h1>Loopback, again</h1></a>
<p>After pairing your laptop to the Bluetooth module, your OS should have created a device file / COM
port for you. On Linux, it should be <code>/dev/rfcomm*</code>; on mac, it should be <code>/dev/cu.*</code>; and on
Windows, it should be a new COM port.</p>
<p>We can now test the Bluetooth module with minicom/PuTTY. Because this module doesn't have LED
indicators for the transmission and reception events like the serial module did, we'll test the
module using a loopback connection:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (loopback)" src="../assets/f3-bluetooth-loopback.png">
</p>
<p>Just connect the module's TXD pin to its RXD pin using a F/F wire.</p>
<p>Now, connect to the device using <code>minicom</code>/<code>PuTTY</code>:</p>
<pre><code class="language-console">$ minicom -D /dev/rfcomm0
</code></pre>
<p>Upon connecting, the blinking pattern of the Bluetooth module should change to: long pause then
blink twice quickly.</p>
<p>Typing inside minicom/PuTTY terminal should echo back what you type.</p>
<a class="header" href="#serial-over-bluetooth" id="serial-over-bluetooth"><h1>Serial over Bluetooth</h1></a>
<p>Now that we verify that the Bluetooth module works with minicom/PuTTY, let's connect it to the
microcontroller:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection" src="../assets/f3-bluetooth.png">
</p>
<p>Recommended steps to wire this up:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code>.</li>
<li>Disconnect the F3 from your laptop.</li>
<li>Connect F3's GND pin to the module's GND pin using a female to female (F/F) wire (preferably, a
black one).</li>
<li>Connect F3's 5V pin to the module's VCC pin using a F/F wire (preferably, a red one).</li>
<li>Connect the PA9 (TX) pin on the back of the F3 to the Bluetooth's RXD pin using a F/F wire.</li>
<li>Connect the PA10 (RX) pin on the back of the F3 to the Bluetooth's TXD pin using a F/F wire.</li>
<li>Now connect the F3 and your laptop using an USB cable.</li>
<li>Re-launch OpenOCD and <code>itmdump</code>.</li>
</ul>
<p>And that's it! You should be able to run all the programs you wrote in <a href="https://docs.rust-embedded.org/11-usart/index.html">section 11</a> without
modification! Just make sure you open the right serial device / COM port.</p>
<p><strong>NOTE</strong> If you are having trouble communicating with the bluetooth device, you may need to initialize USART1 with a lower baud rate. Lowering it from 115,200 bps to 9,600 bps might help, as described <a href="https://github.com/rust-embedded/discovery/blob/master/src/11-usart/auxiliary/src/lib.rs#L31">here</a></p>
<a class="header" href="#i2c" id="i2c"><h1>I2C</h1></a>
<p>We just saw the serial communication protocol. It's a widely used protocol because it's very
simple and this simplicity makes it easy to implement on top of other protocols like Bluetooth and
USB.</p>
<p>However, it's simplicity is also a downside. More elaborated data exchanges, like reading a digital
sensor, would require the sensor vendor to come up with another protocol on top of it.</p>
<p>(Un)Luckily for us, there are <em>plenty</em> of other communication protocols in the embedded space. Some
of them are widely used in digital sensors.</p>
<p>The F3 board we are using has three motion sensors in it: an accelerometer, a magnetometer and
gyroscope. The accelerometer and magnetometer are packaged in a single component and can be accessed
via an I2C bus.</p>
<p>I2C stands for Inter-Integrated Circuit and is a <em>synchronous</em> <em>serial</em> communication protocol. It
uses two lines to exchange data: a data line (SDA) and a clock line (SCL). Because a clock line is
used to synchronize the communication, this is a <em>synchronous</em> protocol.</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<p>This protocol uses a <em>master</em> <em>slave</em> model where the master is the device that <em>starts</em> and
drives the communication with a slave device. Several devices, both masters and slaves, can be
connected to the same bus at the same time. A master device can communicate with a specific slave
device by first broadcasting its <em>address</em> to the bus. This address can be 7 bits or 10 bits long.
Once a master has <em>started</em> a communication with a slave, no other device can make use of the bus
until the master <em>stops</em> the communication.</p>
<p>The clock line determines how fast data can be exchanged and it usually operates at a frequency of
100 KHz (standard mode) or 400 KHz (fast mode).</p>
<a class="header" href="#general-protocol" id="general-protocol"><h1>General protocol</h1></a>
<p>The I2C protocol is more elaborated than the serial communication protocol because it has to support
communication between several devices. Let's see how it works using examples:</p>
<a class="header" href="#master---slave" id="master---slave"><h2>Master -&gt; Slave</h2></a>
<p>If the master wants to send data to the slave:</p>
<p align="center">
  <img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<ol>
<li>Master: Broadcast START</li>
<li>M: Broadcast slave address (7 bits) + the R/W (8th) bit set to WRITE</li>
<li>Slave: Responds ACK (ACKnowledgement)</li>
<li>M: Send one byte</li>
<li>S: Responds ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>M: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The slave address could have been 10 bits instead of 7 bits long. Nothing else would have
changed.</p>
</blockquote>
<a class="header" href="#master---slave-1" id="master---slave-1"><h2>Master &lt;- Slave</h2></a>
<p>If the master wants to read data from the slave:</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<ol>
<li>M: Broadcast START</li>
<li>M: Broadcast slave address (7 bits) + the R/W (8th) bit set to READ</li>
<li>S: Responds with ACK</li>
<li>S: Send byte</li>
<li>M: Responds with ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>M: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The slave address could have been 10 bits instead of 7 bits long. Nothing else would have
changed.</p>
</blockquote>
<a class="header" href="#lsm303dlhc" id="lsm303dlhc"><h1>LSM303DLHC</h1></a>
<p>Two of the sensors in the F3, the magnetometer and the accelerometer, are packaged in a single
component: the LSM303DLHC integrated circuit. These two sensors can be accessed via an I2C bus. Each
sensor behaves like an I2C slave and has a <em>different</em> address.</p>
<p>Each sensor has its own memory where it stores the results of sensing its environment. Our
interaction with these sensors will mainly involve reading their memory.</p>
<p>The memory of these sensors is modeled as byte addressable registers. These sensors can be
configured too; that's done by writing to their registers. So, in a sense, these sensors are very
similar to the peripherals <em>inside</em> the microcontroller. The difference is that their registers are
not mapped into the microcontrollers' memory. Instead, their registers have to be accessed via the
I2C bus.</p>
<p>The main source of information about the LSM303DLHC is its <a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">Data Sheet</a>. Read through it to see how
one can read the sensors' registers. That part is in:</p>
<blockquote>
<p>Section 5.1.1 I2C Operation - Page 20 - LSM303DLHC Data Sheet</p>
</blockquote>
<p>The other part of the documentation relevant to this book is the description of the registers. That
part is in:</p>
<blockquote>
<p>Section 7 Register description - Page 25 - LSM303DLHC Data Sheet</p>
</blockquote>
<a class="header" href="#read-a-single-register" id="read-a-single-register"><h1>Read a single register</h1></a>
<p>Let's put all that theory into practice!</p>
<p>Just like with the USART peripheral, I've taken care of initializing everything before you reach
<code>main</code> so you'll only have to deal with the following registers:</p>
<ul>
<li><code>CR2</code>. Control register 2.</li>
<li><code>ISR</code>. Interrupt and status register.</li>
<li><code>TXDR</code>. Transmit data register.</li>
<li><code>RXDR</code>. Receive data register.</li>
</ul>
<p>These registers are documented in the following section of the Reference Manual:</p>
<blockquote>
<p>Section 28.7 I2C registers - Page 873 - Reference Manual</p>
</blockquote>
<p>We'll be using the <code>I2C1</code> peripheral in conjunction with pins <code>PB6</code> (<code>SCL</code>) and <code>PB7</code> (<code>SDA</code>).</p>
<p>You won't have to wire anything this time because the sensor is on the board and it's already
connected to the microcontroller. However, I would recommend that you disconnect the serial /
Bluetooth module from the F3 to make it easier to manipulate. Later on, we'll be moving the board
around quite a bit.</p>
<p>Your task is to write a program that reads the contents of the magnetometer's <code>IRA_REG_M</code> register.
This register is read only and always contains the value <code>0b01001000</code>.</p>
<p>The microcontroller will be taking the role of the I2C master and the magnetometer inside the
LSM303DLHC will be the I2C slave.</p>
<p>Here's the starter code. You'll have to implement the <code>TODO</code>s.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// Slave address
const MAGNETOMETER: u8 = 0b001_1110;

// Addresses of the magnetometer's registers
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, _delay, mut itm) = aux14::init();

    // Stage 1: Send the address of the register we want to read to the
    // magnetometer
    {
        // TODO Broadcast START

        // TODO Broadcast the MAGNETOMETER address with the R/W bit set to Write

        // TODO Send the address of the register that we want to read: IRA_REG_M
    }

    // Stage 2: Receive the contents of the register we asked for
    let byte = {
        // TODO Broadcast RESTART

        // TODO Broadcast the MAGNETOMETER address with the R/W bit set to Read

        // TODO Receive the contents of the register

        // TODO Broadcast STOP
        0
    };

    // Expected output: 0x0A - 0b01001000
    iprintln!(&amp;mut itm.stim[0], &quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}

</code></pre></pre>
<p>To give you some extra help, these are the exact bitfields you'll be working with:</p>
<ul>
<li><code>CR2</code>: <code>SADD1</code>, <code>RD_WRN</code>, <code>NBYTES</code>, <code>START</code>, <code>AUTOEND</code></li>
<li><code>ISR</code>: <code>TXIS</code>, <code>RXNE</code>, <code>TC</code></li>
<li><code>TXDR</code>: <code>TXDATA</code></li>
<li><code>RXDR</code>: <code>RXDATA</code></li>
</ul>
<a class="header" href="#the-solution-1" id="the-solution-1"><h1>The solution</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// Slave address
const MAGNETOMETER: u8 = 0b001_1110;

// Addresses of the magnetometer's registers
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, _delay, mut itm) = aux14::init();

    // Stage 1: Send the address of the register we want to read to the
    // magnetometer
    {
        // Broadcast START
        // Broadcast the MAGNETOMETER address with the R/W bit set to Write
        i2c1.cr2.write(|w| {
            w.start().set_bit();
            w.sadd1().bits(MAGNETOMETER);
            w.rd_wrn().clear_bit();
            w.nbytes().bits(1);
            w.autoend().clear_bit()
        });

        // Wait until we can send more data
        while i2c1.isr.read().txis().bit_is_clear() {}

        // Send the address of the register that we want to read: IRA_REG_M
        i2c1.txdr.write(|w| w.txdata().bits(IRA_REG_M));

        // Wait until the previous byte has been transmitted
        while i2c1.isr.read().tc().bit_is_clear() {}
    }

    // Stage 2: Receive the contents of the register we asked for
    let byte = {
        // Broadcast RESTART
        // Broadcast the MAGNETOMETER address with the R/W bit set to Read
        i2c1.cr2.modify(|_, w| {
            w.start().set_bit();
            w.nbytes().bits(1);
            w.rd_wrn().set_bit();
            w.autoend().set_bit()
        });

        // Wait until we have received the contents of the register
        while i2c1.isr.read().rxne().bit_is_clear() {}

        // Broadcast STOP (automatic because of `AUTOEND = 1`)

        i2c1.rxdr.read().rxdata().bits()
    };

    // Expected output: 0x0A - 0b01001000
    iprintln!(&amp;mut itm.stim[0], &quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}
</code></pre></pre>
<a class="header" href="#read-several-registers" id="read-several-registers"><h1>Read several registers</h1></a>
<p>Reading the <code>IRA_REG_M</code> register was a good test of our understanding of the I2C protocol but that
register contains uninteresting information.</p>
<p>This time, we'll read the registers of the magnetometer that actually expose the sensor readings.
Six contiguous registers are involved and they start with <code>OUT_X_H_M</code> at address <code>0x03</code>.</p>
<p>We'll modify our previous program to read these six registers. Only a few modifications are needed.</p>
<p>We'll need to change the address we request from the magnetometer from <code>IRA_REG_M</code> to <code>OUT_X_H_M</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Send the address of the register that we want to read: OUT_X_H_M
    i2c1.txdr.write(|w| w.txdata().bits(OUT_X_H_M));
#}</code></pre></pre>
<p>We'll have to request the slave for six bytes rather than just one.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // Broadcast RESTART
    // Broadcast the MAGNETOMETER address with the R/W bit set to Read
    i2c1.cr2.modify(|_, w| {
        w.start().set_bit();
        w.nbytes().bits(6);
        w.rd_wrn().set_bit();
        w.autoend().set_bit()
    });
#}</code></pre></pre>
<p>And fill a buffer rather than read just one byte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut buffer = [0u8; 6];
    for byte in &amp;mut buffer {
        // Wait until we have received the contents of the register
        while i2c1.isr.read().rxne().bit_is_clear() {}

        *byte = i2c1.rxdr.read().rxdata().bits();
    }

    // Broadcast STOP (automatic because of `AUTOEND = 1`)
#}</code></pre></pre>
<p>Putting it all together inside a loop alongside a delay to reduce the data throughput:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// Slave address
const MAGNETOMETER: u8 = 0b001_1110;

// Addresses of the magnetometer's registers
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, mut delay, mut itm) = aux14::init();

    loop {
        // Broadcast START
        // Broadcast the MAGNETOMETER address with the R/W bit set to Write
        i2c1.cr2.write(|w| {
            w.start().set_bit();
            w.sadd1().bits(MAGNETOMETER);
            w.rd_wrn().clear_bit();
            w.nbytes().bits(1);
            w.autoend().clear_bit()
        });

        // Wait until we can send more data
        while i2c1.isr.read().txis().bit_is_clear() {}

        // Send the address of the register that we want to read: IRA_REG_M
        i2c1.txdr.write(|w| w.txdata().bits(OUT_X_H_M));

        // Wait until the previous byte has been transmitted
        while i2c1.isr.read().tc().bit_is_clear() {}

        // Broadcast RESTART
        // Broadcast the MAGNETOMETER address with the R/W bit set to Read
        i2c1.cr2.modify(|_, w| {
            w.start().set_bit();
            w.nbytes().bits(6);
            w.rd_wrn().set_bit();
            w.autoend().set_bit()
        });

        let mut buffer = [0u8; 6];
        for byte in &amp;mut buffer {
            // Wait until we have received something
            while i2c1.isr.read().rxne().bit_is_clear() {}

            *byte = i2c1.rxdr.read().rxdata().bits();
        }
        // Broadcast STOP (automatic because of `AUTOEND = 1`)

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, buffer);

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<p>If you run this, you should printed in the <code>itmdump</code>'s console a new array of six bytes every
second. The values within the array should change if you move around the board.</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
[0, 45, 255, 251, 0, 193]
[0, 44, 255, 249, 0, 193]
[0, 49, 255, 250, 0, 195]
</code></pre>
<p>But these bytes don't make much sense like that. Let's turn them into actual readings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        let x_h = u16::from(buffer[0]);
        let x_l = u16::from(buffer[1]);
        let z_h = u16::from(buffer[2]);
        let z_l = u16::from(buffer[3]);
        let y_h = u16::from(buffer[4]);
        let y_l = u16::from(buffer[5]);

        let x = ((x_h &lt;&lt; 8) + x_l) as i16;
        let y = ((y_h &lt;&lt; 8) + y_l) as i16;
        let z = ((z_h &lt;&lt; 8) + z_l) as i16;

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, (x, y, z));
#}</code></pre></pre>
<p>Now it should look better:</p>
<pre><code class="language-console">$ # `itmdump terminal
(..)
(44, 196, -7)
(45, 195, -6)
(46, 196, -9)
</code></pre>
<p>This is the Earth's magnetic field decomposed alongside the XYZ axis of the magnetometer.</p>
<p>In the next section, we'll learn how to make sense of these numbers.</p>
<a class="header" href="#led-compass" id="led-compass"><h1>LED compass</h1></a>
<p>In this section, we'll implement a compass using the LEDs on the F3. Like proper compasses, our LED
compass must point north somehow. It will do that by turning on one of its eight LEDs; the on LED
should point towards north.</p>
<p>Magnetic fields have both a magnitude, measured in Gauss or Teslas, and a <em>direction</em>. The
magnetometer on the F3 measures both the magnitude and the direction of an external magnetic field
but it reports back the <em>decomposition</em> of said field along <em>its axes</em>.</p>
<p>See below, the magnetometer has three axes associated to it.</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="https://docs.rust-embedded.org/assets/f3-lsm303dlhc.png">
</p>
<p>Only the X and Y axes are shown above. The Z axis is pointing &quot;out&quot; of your screen.</p>
<p>Let's get familiar with the readings of the magnetometer by running the following starter code:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*};

#[entry]
fn main() -&gt; ! {
    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, lsm303dlhc.mag().unwrap());
        delay.delay_ms(1_000_u16);
    }
}

</code></pre></pre>
<p>This <code>lsm303dlhc</code> module provides high level API over the LSM303DLHC. Under the hood it does the
same I2C routine that you implemented in the last section but it reports the X, Y and Z values in a
<code>I16x3</code> struct instead of a tuple.</p>
<p>Locate where north is at your current location. Then rotate the board such that it's aligned
&quot;towards north&quot;: the North LED (LD3) should be pointing towards north.</p>
<p>Now run the starter code and observe the output. What X, Y and Z values do you see?</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
I16x3 { x: 45, y: 194, z: -3 }
I16x3 { x: 46, y: 195, z: -8 }
I16x3 { x: 47, y: 197, z: -2 }
</code></pre>
<p>Now rotate the board 90 degrees while keeping it parallel to the ground. What X, Y and Z values do
you see this time? Then rotate it 90 degrees again. What values do you see?</p>
<a class="header" href="#take-1" id="take-1"><h1>Take 1</h1></a>
<p>What's the simplest way in which we can implement the LED compass? Even if it's not perfect.</p>
<p>For starters, we'd only care about the X and Y components of the magnetic field because when you
look at a compass you always hold it in horizontal position thus the compass is in the XY plane.</p>
<p>For example, what LED would you turn on in the following case. EMF stands for Earth's Magnetic Field
and green arrow has the direction of the EMF (it points north).</p>
<p align="center">
<img title="Quadrant I" src="https://docs.rust-embedded.org/assets/quadrant-i.png">
</p
<p>The <code>Southeast</code> LED, right?</p>
<p>What <em>signs</em> do the X and Y components of the magnetic field have in that scenario? Both are
positive.</p>
<p>If we only looked at the signs of the X and Y components we could determine to which quadrant the
magnetic field belongs to.</p>
<p align="center">
<img title="Quadrants" src="https://docs.rust-embedded.org/assets/quadrants.png">
</p>
<p>In the previous example, the magnetic field was in the first quadrant (x and y were positive) and it
made sense to turn on the <code>SouthEast</code> LED. Similarly, we could turn a different LED if the magnetic
field was in a different quadrant.</p>
<p>Let's try that logic. Here's the starter code:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        // Look at the signs of the X and Y components to determine in which
        // quadrant the magnetic field is
        let dir = match (x &gt; 0, y &gt; 0) {
            // Quadrant ???
            (true, true) =&gt; Direction::Southeast,
            // Quadrant ???
            (false, true) =&gt; panic!(&quot;TODO&quot;),
            // Quadrant ???
            (false, false) =&gt; panic!(&quot;TODO&quot;),
            // Quadrant ???
            (true, false) =&gt; panic!(&quot;TODO&quot;),
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<p>There's a <code>Direction</code> enum in the <code>led</code> module that has 8 variants named after the cardinal points:
<code>North</code>, <code>East</code>, <code>Southwest</code>, etc. Each of these variants represent one of the 8 LEDs in the
compass. The <code>Leds</code> value can be indexed using the <code>Direction</code> <code>enum</code>; the result of indexing is the
LED that points in that <code>Direction</code>.</p>
<a class="header" href="#solution-1" id="solution-1"><h1>Solution 1</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        // Look at the signs of the X and Y components to determine in which
        // quadrant the magnetic field is
        let dir = match (x &gt; 0, y &gt; 0) {
            // Quadrant I
            (true, true) =&gt; Direction::Southeast,
            // Quadrant II
            (false, true) =&gt; Direction::Northeast,
            // Quadrant III
            (false, false) =&gt; Direction::Northwest,
            // Quadrant IV
            (true, false) =&gt; Direction::Southwest,
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<a class="header" href="#take-2" id="take-2"><h1>Take 2</h1></a>
<p>This time, we'll use math to get the precise angle that the magnetic field forms with the X and Y
axes of the magnetometer.</p>
<p>We'll use the <code>atan2</code> function. This function returns an angle in the <code>-PI</code> to <code>PI</code> range. The
graphic below shows how this angle is measured:</p>
<p align="center">
<img title="atan2" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Atan2_60.svg">
</p>
<p>Although not explicitly shown in this graph the X axis points to the right and the Y axis points up.</p>
<p>Here's the starter code. <code>theta</code>, in radians, has already been computed. You need to pick which LED
to turn on based on the value of <code>theta</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// You'll find this useful ;-)
use core::f32::consts::PI;

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};
// this trait provides the `atan2` method
use m::Float;

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        let _theta = (y as f32).atan2(x as f32); // in radians

        // FIXME pick a direction to point to based on `theta`
        let dir = Direction::Southeast;

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<p>Suggestions/tips:</p>
<ul>
<li>A whole circle rotation equals 360 degrees.</li>
<li><code>PI</code> radians is equivalent to 180 degrees.</li>
<li>If <code>theta</code> was zero, what LED would you turn on?</li>
<li>If <code>theta</code> was, instead, very close to zero, what LED would you turn on?</li>
<li>If <code>theta</code> kept increasing, at what value would you turn on a different LED?</li>
</ul>
<a class="header" href="#solution-2" id="solution-2"><h1>Solution 2</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// You'll find this useful ;-)
use core::f32::consts::PI;

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};
use m::Float;

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        let theta = (y as f32).atan2(x as f32); // in radians

        let dir = if theta &lt; -7. * PI / 8. {
            Direction::North
        } else if theta &lt; -5. * PI / 8. {
            Direction::Northwest
        } else if theta &lt; -3. * PI / 8. {
            Direction::West
        } else if theta &lt; -PI / 8. {
            Direction::Southwest
        } else if theta &lt; PI / 8. {
            Direction::South
        } else if theta &lt; 3. * PI / 8. {
            Direction::Southeast
        } else if theta &lt; 5. * PI / 8. {
            Direction::East
        } else if theta &lt; 7. * PI / 8. {
            Direction::Northeast
        } else {
            Direction::North
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<a class="header" href="#magnitude" id="magnitude"><h1>Magnitude</h1></a>
<p>We have been working with the direction of the magnetic field but what's its real magnitude? The
number that the <code>magnetic_field</code> function reports are unit-less. How can we convert those values to
Gauss?</p>
<p>The documentation will answer that question.</p>
<blockquote>
<p>Section 2.1 Sensor characteristics - Page 10 - LSM303DLHC Data Sheet</p>
</blockquote>
<p>The table in that page shows a <em>magnetic gain setting</em> that has different values according to the
values of the GN bits. By default, those GN bits are set to <code>001</code>. That means that magnetic gain of
the X and Y axes is <code>1100 LSB / Gauss</code> and the magnetic gain of the Z axis is <code>980 LSB / Gauss</code>. LSB
stands for Least Significant Bits and the <code>1100 LSB / Gauss</code> number indicates that a reading of
<code>1100</code> is equivalent to <code>1 Gauss</code>, a reading of <code>2200</code> is equivalent to 2 Gauss and so on.</p>
<p>So, what we need to do is divide the X, Y and Z values that the sensor outputs by its corresponding
<em>gain</em>. Then, we'll have the X, Y and Z components of the magnetic field in Gauss.</p>
<p>With some extra math we can retrieve the magnitude of the magnetic field from its X, Y and Z
components:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let magnitude = (x * x + y * y + z * z).sqrt();
#}</code></pre></pre>
<p>Putting all this together in a program:</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, I16x3};
use m::Float;

#[entry]
fn main() -&gt; ! {
    const XY_GAIN: f32 = 1100.; // LSB / G
    const Z_GAIN: f32 = 980.; // LSB / G

    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        let I16x3 { x, y, z } = lsm303dlhc.mag().unwrap();

        let x = f32::from(x) / XY_GAIN;
        let y = f32::from(y) / XY_GAIN;
        let z = f32::from(z) / Z_GAIN;

        let mag = (x * x + y * y + z * z).sqrt();

        iprintln!(&amp;mut itm.stim[0], &quot;{} mG&quot;, mag * 1_000.);

        delay.delay_ms(500_u16);
    }
}
</code></pre></pre>
<p>This program will report the magnitude (strength) of the magnetic field in milligauss (<code>mG</code>). The
magnitude of the Earth's magnetic field is in the range of <code>250 mG</code> to <code>650 mG</code> (the magnitude
varies depending on your geographical location) so you should see a value in that range or close to
that range -- I see a magnitude of around 210 mG.</p>
<p>Some questions:</p>
<p>Without moving the board, what value do you see? Do you always see the same value?</p>
<p>If you rotate the board, does the magnitude change? Should it change?</p>
<a class="header" href="#calibration" id="calibration"><h1>Calibration</h1></a>
<p>If we rotate the board, the direction of the Earth's magnetic field with respect to the magnetometer
should change but its magnitude should not! Yet, the magnetometer indicates that the magnitude of
the magnetic field changes as the board rotates.</p>
<p>Why's that the case? Turns out the magnetometer needs to be calibrated to return the correct answer.</p>
<p>The calibration involves quite a bit of math (matrices) so we won't cover it here but this
<a href="http://cache.freescale.com/files/sensors/doc/app_note/AN4246.pdf">Application Note</a> describes the procedure if you are interested. Instead, what we'll do in this
section is <em>visualize</em> how off we are.</p>
<p>Let's try this experiment: Let's record the readings of the magnetometer while we slowly rotate the
board in different directions. We'll use the <code>iprintln</code> macro to format the readings as Tab
Separated Values (TSV).</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, I16x3};

#[entry]
fn main() -&gt; ! {
    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        let I16x3 { x, y, z } = lsm303dlhc.mag().unwrap();

        iprintln!(&amp;mut itm.stim[0], &quot;{}\t{}\t{}&quot;, x, y, z);

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<p>You should get an output in the console that looks like this:</p>
<pre><code class="language-console">$ # itmdump console
-76     213     -54
-76     213     -54
-76     213     -54
-76     213     -54
-73     213     -55
</code></pre>
<p>You can pipe that to a file using:</p>
<pre><code class="language-console">$ # Careful! Exit any running other `itmdump` instance that may be running
$ itmdump -F -f itm.txt &gt; emf.txt
</code></pre>
<p>Rotate the board in many different direction while you log data for a several seconds.</p>
<p>Then import that TSV file into a spreadsheet program (or use the Python script shown below) and plot
the first two columns as a scatter plot.</p>
<pre><code class="language-python">#!/usr/bin/python

import csv
import math
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import sys

# apply plot style
sns.set()

x = []
y = []

with open(sys.argv[1], 'r') as f:
    rows = csv.reader(f, delimiter='\t')

    for row in rows:
        # discard rows that are missing data
        if len(row) != 3 or not row[0] or not row[1]:
            continue

        x.append(int(row[0]))
        y.append(int(row[1]))

r = math.ceil(max(max(np.abs(x)), max(np.abs(y))) / 100) * 100

plt.plot(x, y, '.')
plt.xlim(-r, r)
plt.ylim(-r, r)
plt.gca().set_aspect(1)
plt.tight_layout()

plt.savefig('emf.svg')
plt.close
</code></pre>
<p align="center">
<img title="Earth's magnetic field" src="https://docs.rust-embedded.org/assets/emf.svg">
</p>
<p>If you rotated the board on a flat horizontal surface, the Z component of the magnetic field should
have remained relatively constant and this plot should have been a circumference (not a ellipse)
centered at the origin. If you rotated the board in random directions, which was the case of plot
above, then you should have gotten a circle made of a bunch of points centered at the origin.
Deviations from the circle shape indicate that the magnetometer needs to be calibrated.</p>
<p>Take home message: Don't just trust the reading of a sensor. Verify it's outputting sensible values.
If it's not, then calibrate it.</p>
<a class="header" href="#punch-o-meter" id="punch-o-meter"><h1>Punch-o-meter</h1></a>
<p>In this section we'll be playing with the accelerometer that's in the board.</p>
<p>What are we building this time? A punch-o-meter! We'll be measuring the power of your jabs. Well,
actually the maximum acceleration that you can reach because acceleration is what accelerometers
measure. Strength and acceleration are proportional though so it's a good approximation.</p>
<p>The accelerometer is also built inside the LSM303DLHC package. And just like the magnetometer, it
can also be accessed using the I2C bus. It also has the same coordinate system as the magnetometer.
Here's the coordinate system again:</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="https://docs.rust-embedded.org/assets/f3-lsm303dlhc.png">
</p>
<p>Just like in the previous unit, we'll be using a high level API to directly get the sensor readings
in a nicely packaged <code>struct</code>.</p>
<a class="header" href="#gravity-is-up" id="gravity-is-up"><h1>Gravity is up?</h1></a>
<p>What's the first thing we'll do?</p>
<p>Perform a sanity check!</p>
<p>The starter code prints the X, Y and Z components of the acceleration measured by the accelerometer.
The values have already been &quot;scaled&quot; and have units of <code>g</code>s. Where <code>1 g</code> is equal to the
acceleration of the gravity, about <code>9.8</code> meters per second squared.</p>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux16::{entry, iprint, iprintln, prelude::*, I16x3, Sensitivity};

#[entry]
fn main() -&gt; ! {
    let (mut lsm303dlhc, mut delay, _mono_timer, mut itm) = aux16::init();

    // extend sensing range to `[-12g, +12g]`
    lsm303dlhc.set_accel_sensitivity(Sensitivity::G12).unwrap();
    loop {
        const SENSITIVITY: f32 = 12. / (1 &lt;&lt; 14) as f32;

        let I16x3 { x, y, z } = lsm303dlhc.accel().unwrap();

        let x = f32::from(x) * SENSITIVITY;
        let y = f32::from(y) * SENSITIVITY;
        let z = f32::from(z) * SENSITIVITY;

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, (x, y, z));

        delay.delay_ms(1_000_u16);
    }
}

</code></pre></pre>
<p>The output of this program with the board sitting still will be something like:</p>
<pre><code class="language-console">$ # itmdump console
(..)
(0.0, 0.0, 1.078125)
(0.0, 0.0, 1.078125)
(0.0, 0.0, 1.171875)
(0.0, 0.0, 1.03125)
(0.0, 0.0, 1.078125)
</code></pre>
<p>Which is weird because the board is not moving yet its acceleration is non-zero. What's going on?
This must be related to the gravity, right? Because the acceleration of gravity is <code>1 g</code>. But the
gravity pulls objects downwards so the acceleration along the Z axis should be negative not positive
...</p>
<p>Did the program get the Z axis backwards? Nope, you can test rotating the board to align the gravity
to the X or Y axis but the acceleration measured by the accelerometer is always pointing up.</p>
<p>What happens here is that the accelerometer is measuring the <em>proper acceleration</em> of the board not
the acceleration <em>you</em> are observing. This proper acceleration is the acceleration of the board as
seen from a observer that's in free fall. An observer that's in free fall is moving toward the
center of the the Earth with an acceleration of <code>1g</code>; from its point of view the board is actually
moving upwards (away from the center of the Earth) with an acceleration of <code>1g</code>. And that's why the
proper acceleration is pointing up. This also means that if the board was in free fall, the
accelerometer would report a proper acceleration of zero. Please, don't try that at home.</p>
<p>Yes, physics is hard. Let's move on.</p>
<a class="header" href="#the-challenge-1" id="the-challenge-1"><h1>The challenge</h1></a>
<p>To keep things simple, we'll measure the acceleration only in the X axis while the board remains
horizontal. That way we won't have to deal with subtracting that <em>fictitious</em> <code>1g</code> we observed
before which would be hard because that <code>1g</code> could have X Y Z components depending on how the board
is oriented.</p>
<p>Here's what the punch-o-meter must do:</p>
<ul>
<li>By default, the app is not &quot;observing&quot; the acceleration of the board.</li>
<li>When a significant X acceleration is detected (i.e. the acceleration goes above some threshold),
the app should start a new measurement.</li>
<li>During that measurement interval, the app should keep track of the maximum acceleration observed</li>
<li>After the measurement interval ends, the app must report the maximum acceleration observed. You
can report the value using the <code>iprintln</code> macro.</li>
</ul>
<p>Give it a try and let me know how hard you can punch <code>;-)</code>.</p>
<a class="header" href="#my-solution-2" id="my-solution-2"><h1>My solution</h1></a>
<pre><pre class="playpen"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux16::{entry, iprint, iprintln, prelude::*, I16x3, Sensitivity};
use m::Float;

#[entry]
fn main() -&gt; ! {
    const SENSITIVITY: f32 = 12. / (1 &lt;&lt; 14) as f32;
    const THRESHOLD: f32 = 0.5;

    let (mut lsm303dlhc, mut delay, mono_timer, mut itm) = aux16::init();

    lsm303dlhc.set_accel_sensitivity(Sensitivity::G12).unwrap();

    let measurement_time = mono_timer.frequency().0; // 1 second in ticks
    let mut instant = None;
    let mut max_g = 0.;
    loop {
        let g_x = f32::from(lsm303dlhc.accel().unwrap().x).abs() * SENSITIVITY;

        match instant {
            None =&gt; {
                // If acceleration goes above a threshold, we start measuring
                if g_x &gt; THRESHOLD {
                    iprintln!(&amp;mut itm.stim[0], &quot;START!&quot;);

                    max_g = g_x;
                    instant = Some(mono_timer.now());
                }
            }
            // Still measuring
            Some(ref instant) if instant.elapsed() &lt; measurement_time =&gt; {
                if g_x &gt; max_g {
                    max_g = g_x;
                }
            }
            _ =&gt; {
                // Report max value
                iprintln!(&amp;mut itm.stim[0], &quot;Max acceleration: {}g&quot;, max_g);

                // Measurement done
                instant = None;

                // Reset
                max_g = 0.;
            }
        }

        delay.delay_ms(50_u8);
    }
}
</code></pre></pre>
<a class="header" href="#whats-left-for-you-to-explore" id="whats-left-for-you-to-explore"><h1>What's left for you to explore</h1></a>
<p>We have barely scratched the surface! There's lots of stuff left for you to explore:</p>
<a class="header" href="#multitasking" id="multitasking"><h2>Multitasking</h2></a>
<p>All our programs executed a single task. How could we achieve multitasking in a system with no OS,
and thus no threads. There are two main approaches to multitasking: preemptive multitasking and
cooperative multitasking.</p>
<p>In preemptive multitasking a task that's currently being executed can, at any point in time, be
<em>preempted</em> (interrupted) by another task. On preemption, the first task will be suspended and the
processor will instead execute the second task. At some point the first task will be resumed.
Microcontrollers provide hardware support for preemption in the form of <em>interrupts</em>.</p>
<p>In cooperative multitasking a task that's being executed will run until it reaches a <em>suspension
point</em>. When the processor reaches that suspension point it will stop executing the current task and
instead go and execute a different task. At some point the first task will be resumed. The main
difference between these two approaches to multitasking is that in cooperative multitasking <em>yields</em>
execution control at <em>known</em> suspension points instead of being forcefully preempted at any point of
its execution.</p>
<a class="header" href="#direct-memory-access-dma" id="direct-memory-access-dma"><h2>Direct Memory Access (DMA).</h2></a>
<p>This peripheral is a kind of <em>asynchronous</em> <code>memcpy</code>. So far our programs have
been pumping data, byte by byte, into peripherals like UART and I2C. This DMA
peripheral can be used to perform bulk transfers of data. Either from RAM to
RAM, from a peripheral, like a UART, to RAM or from RAM to a peripheral. You can
schedule a DMA transfer, like read 256 bytes from USART1 into this buffer, leave
it running in the background and then poll some register to see if it has
completed so you can do other stuff while the transfer is ongoing.</p>
<a class="header" href="#sleeping" id="sleeping"><h2>Sleeping</h2></a>
<p>All our programs have been continuously polling peripherals to see if there's
anything that needs to be done. However, some times there's nothing to be done!
At those times, the microcontroller should &quot;sleep&quot;.</p>
<p>When the processor sleeps, it stops executing instructions and this saves power.
It's almost always a good idea to save power so your microcontroller should be
sleeping as much as possible. But, how does it know when it has to wake up to
perform some action? &quot;Interrupts&quot; are one of the events that wake up the
microcontroller but there are others and the <code>wfi</code> and <code>wfe</code> are the
instructions that make the processor &quot;sleep&quot;.</p>
<a class="header" href="#pulse-width-modulation-pwm" id="pulse-width-modulation-pwm"><h2>Pulse Width Modulation (PWM)</h2></a>
<p>In a nutshell, PWM is turning on something and then turning it off periodically
while keeping some proportion (&quot;duty cycle&quot;) between the &quot;on time&quot; and the &quot;off
time&quot;. When used on a LED with a sufficiently high frequency, this can be used
to dim the LED. A low duty cycle, say 10% on time and 90% off time, will make
the LED very dim wheres a high duty cycle, say 90% on time and 10% off time,
will make the LED much brighter (almost as if it were fully powered).</p>
<p>In general, PWM can be used to control how much <em>power</em> is given to some
electric device. With proper (power) electronics between a microcontroller and
an electrical motor, PWM can be used to control how much power is given to the
motor thus it can be used to control its torque and speed. Then you can add an
angular position sensor and you got yourself a closed loop controller that can
control the position of the motor at different loads.</p>
<a class="header" href="#digital-input" id="digital-input"><h2>Digital input</h2></a>
<p>We have used the microcontroller pins as digital outputs, to drive LEDs. But
these pins can also be configured as digital inputs. As digital inputs, these
pins can read the binary state of switches (on/off) or buttons (pressed/not
pressed).</p>
<p>(<em>spoilers</em> reading the binary state of switches / buttons is not as
straightforward as it sounds ;-)</p>
<a class="header" href="#sensor-fusion" id="sensor-fusion"><h2>Sensor fusion</h2></a>
<p>The STM32F3DISCOVERY contains three motion sensors: an accelerometer, a
gyroscope and a magnetometer. On their own these measure: (proper) acceleration,
angular speed and (the Earth's) magnetic field. But these magnitudes can be
&quot;fused&quot; into something more useful: a &quot;robust&quot; measurement of the orientation of
the board. Where robust means with less measurement error than a single sensor
would be capable of.</p>
<p>This idea of deriving more reliable data from different sources is known as
sensor fusion.</p>
<a class="header" href="#analog-to-digital-converters-adc" id="analog-to-digital-converters-adc"><h2>Analog-to-Digital Converters (ADC)</h2></a>
<p>There are a lots of digital sensors out there. You can use a protocol like I2C
and SPI to read them. But analog sensors also exist! These sensors just output a
voltage level that's proportional to the magnitude they are sensing.</p>
<p>The ADC peripheral can be use to convert that &quot;analog&quot; voltage level, say <code>1.25</code>
Volts,into a &quot;digital&quot; number, say in the <code>[0, 65535]</code> range, that the processor
can use in its calculations.</p>
<a class="header" href="#digital-to-analog-converters-dac" id="digital-to-analog-converters-dac"><h2>Digital-to-Analog Converters (DAC)</h2></a>
<p>As you might expect a DAC is exactly the opposite of ADC. You can write some
digital value into a register to produce a voltage in the <code>[0, 3.3V]</code> range
(assuming a <code>3.3V</code> power supply) on some &quot;analog&quot; pin. When this analog pin is
connected to some appropriate electronics and the register is written to at some
constant, fast rate (frequency) with the right values you can produce sounds or
even music!</p>
<a class="header" href="#real-time-clock-rtc" id="real-time-clock-rtc"><h2>Real Time Clock (RTC)</h2></a>
<p>This peripheral can be used to track time in &quot;human format&quot;. Seconds, minutes,
hours, days, months and years. This peripheral handles the translation from
&quot;ticks&quot; to these human friendly units of time. It even handles leap years and
Daylight Save Time for you!</p>
<a class="header" href="#other-communication-protocols" id="other-communication-protocols"><h2>Other communication protocols</h2></a>
<p>SPI, I2S, SMBUS, CAN, IrDA, Ethernet, USB, Bluetooth, etc.</p>
<p>Different applications use different communication protocols. User facing
applications usually have an USB connector because USB is an ubiquitous
protocol in PCs and smartphones. Whereas inside cars you'll find plenty of CAN
&quot;buses&quot;. Some digital sensors use SPI, others use I2C and others, SMBUS.</p>
<hr />
<p>So where to next? There are several options:</p>
<ul>
<li>You could check out the examples in the <a href="https://docs.rs/f3"><code>f3</code></a> board support crate. All those examples work for
the STM32F3DISCOVERY board you have.</li>
</ul>
<ul>
<li>You could try out <a href="https://mobile.twitter.com/japaricious/status/962770003325005824">this motion sensors demo</a>. Details about the implementation and
source code are available in <a href="http://blog.japaric.io/wd-1-2-l3gd20-lsm303dlhc-madgwick/">this blog post</a>.</li>
</ul>
<ul>
<li>You could check out <a href="https://docs.rs/cortex-m-rtfm">Real Time for The Masses</a>. A very efficient preemptive multitasking framework
that supports task prioritization and dead lock free execution.</li>
</ul>
<ul>
<li>You could try running Rust on a different development board. The easiest way to get started is to
use the <a href="https://docs.rs/cortex-m-quickstart/0.2.4/cortex_m_quickstart"><code>cortex-m-quickstart</code></a> Cargo project template.</li>
</ul>
<ul>
<li>You could check out <a href="http://blog.japaric.io/brave-new-io/">this blog post</a> which describes how Rust type system can
prevent bugs in I/O configuration.</li>
</ul>
<ul>
<li>You could check out my <a href="http://blog.japaric.io/">blog</a> for miscellaneous topics about embedded development with Rust.</li>
</ul>
<ul>
<li>You could check out the <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> project which aims to build abstractions (traits) for all
the embedded I/O functionality commonly found on microcontrollers.</li>
</ul>
<ul>
<li>You could join the <a href="https://github.com/rust-lang-nursery/embedded-wg/issues/39">Weekly driver initiative</a> and help us write generic drivers on top of the
<code>embedded-hal</code> traits and that work for all sorts of platforms (ARM Cortex-M, AVR, MSP430, RISCV,
etc.)</li>
</ul>
<a class="header" href="#general-troubleshooting" id="general-troubleshooting"><h1>General troubleshooting</h1></a>
<a class="header" href="#openocd-problems" id="openocd-problems"><h2>OpenOCD problems</h2></a>
<a class="header" href="#cant-connect-to-openocd---error-open-failed" id="cant-connect-to-openocd---error-open-failed"><h3>can't connect to OpenOCD - &quot;Error: open failed&quot;</h3></a>
<a class="header" href="#symptoms" id="symptoms"><h4>Symptoms</h4></a>
<p>Upon trying to establish a <em>new connection</em> with the device you get an error
that looks like this:</p>
<pre><code>$ openocd -f (..)
(..)
Error: open failed
in procedure 'init'
in procedure 'ocd_bouncer'
</code></pre>
<a class="header" href="#cause--fix" id="cause--fix"><h4>Cause + Fix</h4></a>
<ul>
<li>All: The device is not (properly) connected. Check the USB connection using
<code>lsusb</code> or the Device Manager.</li>
<li>Linux: You may not have enough permission to open the device. Try again with
<code>sudo</code>. If that works, you can use <a href="https://docs.rust-embedded.org/03-setup/linux.html#udev-rules">these instructions</a> to make OpenOCD work
without root privilege.</li>
<li>Windows: You are probably missing the ST-LINK USB driver. Installation
instructions <a href="https://docs.rust-embedded.org/03-setup/windows.html#st-link-usb-driver">here</a>.</li>
</ul>
<a class="header" href="#cant-connect-to-openocd---polling-again-in-x00ms" id="cant-connect-to-openocd---polling-again-in-x00ms"><h3>can't connect to OpenOCD - &quot;Polling again in X00ms&quot;</h3></a>
<a class="header" href="#symptoms-1" id="symptoms-1"><h4>Symptoms</h4></a>
<p>Upon trying to establish a <em>new connection</em> with the device you get an error
that looks like this:</p>
<pre><code>$ openocd -f (..)
(..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<a class="header" href="#cause" id="cause"><h4>Cause</h4></a>
<p>The microcontroller may have get stuck in some tight infinite loop or it may be
continuously raising an exception, e.g. the exception handler is raising an
exception.</p>
<a class="header" href="#fix" id="fix"><h4>Fix</h4></a>
<ul>
<li>Close OpenOCD, if running</li>
<li>Press and hold the reset (black) button</li>
<li>Launch the OpenOCD command</li>
<li>Now, release the reset button</li>
</ul>
<a class="header" href="#openocd-connection-lost---polling-again-in-x00ms" id="openocd-connection-lost---polling-again-in-x00ms"><h3>OpenOCD connection lost - &quot;Polling again in X00ms&quot;</h3></a>
<a class="header" href="#symptoms-2" id="symptoms-2"><h4>Symptoms</h4></a>
<p>A <em>running</em> OpenOCD session suddenly errors with:</p>
<pre><code># openocd -f (..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<a class="header" href="#cause-1" id="cause-1"><h4>Cause</h4></a>
<p>The USB connection was lost.</p>
<a class="header" href="#fix-1" id="fix-1"><h4>Fix</h4></a>
<ul>
<li>Close OpenOCD</li>
<li>Disconnect and re-connect the USB cable.</li>
<li>Re-launch OpenOCD</li>
</ul>
<a class="header" href="#cant-flash-the-device---ignoring-packet-error-continuing" id="cant-flash-the-device---ignoring-packet-error-continuing"><h3>Can't flash the device - &quot;Ignoring packet error, continuing...&quot;</h3></a>
<a class="header" href="#symptoms-3" id="symptoms-3"><h4>Symptoms</h4></a>
<p>While flashing the device, you get:</p>
<pre><code>$ arm-none-eabi-gdb $file
Start address 0x8000194, load size 31588
Transfer rate: 22 KB/sec, 5264 bytes/write.
Ignoring packet error, continuing...
Ignoring packet error, continuing...
</code></pre>
<a class="header" href="#cause-2" id="cause-2"><h4>Cause</h4></a>
<p>Closed <code>itmdump</code> while a program that &quot;printed&quot; to the ITM was running. The
current GDB session will appear to work normally, just without ITM output but
the next GDB session will error with the message that was shown in the previous
section.</p>
<p>Or, <code>itmdump</code> was called <strong>after</strong> the <code>monitor tpiu</code> was issued thus making
<code>itmdump</code> delete the file / named-pipe that OpenOCD was writing to.</p>
<a class="header" href="#fix-2" id="fix-2"><h4>Fix</h4></a>
<ul>
<li>Close/kill GDB, OpenOCD and <code>itmdump</code></li>
<li>Remove the file / named-pipe that <code>itmdump</code> was using (for example,
<code>itm.txt</code>).</li>
<li>Launch OpenOCD</li>
<li>Then, launch <code>itmdump</code></li>
<li>Then, launch the GDB session that executes the <code>monitor tpiu</code> command.</li>
</ul>
<a class="header" href="#cargo-problems" id="cargo-problems"><h2>Cargo problems</h2></a>
<a class="header" href="#cant-find-crate-for-core" id="cant-find-crate-for-core"><h3>&quot;can't find crate for <code>core</code>&quot;</h3></a>
<a class="header" href="#symptoms-4" id="symptoms-4"><h4>Symptoms</h4></a>
<pre><code>   Compiling volatile-register v0.1.2
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
Build failed, waiting for other jobs to finish...
error: Could not compile `r0`.

To learn more, run the command again with --verbose.
</code></pre>
<a class="header" href="#cause-3" id="cause-3"><h4>Cause</h4></a>
<p>You are using a toolchain older than <code>nightly-2018-04-08</code> and forgot to call <code>rustup target add thumbv7em-none-eabihf</code>.</p>
<a class="header" href="#fix-3" id="fix-3"><h4>Fix</h4></a>
<p>Update your nightly and install the <code>thumbv7em-none-eabihf</code> target.</p>
<pre><code class="language-console">$ rustup update nightly

$ rustup target add thumbv7em-none-eabihf
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>

<!-- Mirrored from docs.rust-embedded.org/discovery/print.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 03 Nov 2019 13:54:20 GMT -->
</html>
